// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalKey {
    /// The identifier uses the package-id reference format.
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<super::Identifier>,
    #[prost(string, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub key: ::core::option::Option<super::Value>,
    #[prost(bytes = "vec", tag = "4")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareSubmissionRequest {
    /// Uniquely identifies the participant user that prepares the transaction.
    /// Must be a valid UserIdString (as described in ``value.proto``).
    /// Required unless authentication is used with a user token.
    /// In that case, the token's user-id will be used for the request's user_id.
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// Uniquely identifies the command.
    /// The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
    /// where act_as is interpreted as a set of party names.
    /// The change ID can be used for matching the intended ledger changes with all their completions.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "2")]
    pub command_id: ::prost::alloc::string::String,
    /// Individual elements of this atomic command. Must be non-empty.
    /// Required
    #[prost(message, repeated, tag = "3")]
    pub commands: ::prost::alloc::vec::Vec<super::Command>,
    /// Optional
    #[prost(message, optional, tag = "4")]
    pub min_ledger_time: ::core::option::Option<MinLedgerTime>,
    /// Set of parties on whose behalf the command should be executed, if submitted.
    /// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
    /// to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
    /// and does not execute it. Therefore read authorization is sufficient even for actAs parties.
    /// Note: This may change, and more specific authorization scope may be introduced in the future.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Required, must be non-empty.
    #[prost(string, repeated, tag = "5")]
    pub act_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
    /// This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
    /// Note: A command can only use contracts that are visible to at least
    /// one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
    /// rules for fetch operations.
    /// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
    /// to read contract data on behalf of each of the given parties.
    /// Optional
    #[prost(string, repeated, tag = "6")]
    pub read_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional contracts used to resolve contract & contract key lookups.
    /// Optional
    #[prost(message, repeated, tag = "7")]
    pub disclosed_contracts: ::prost::alloc::vec::Vec<super::DisclosedContract>,
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "8")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// The package-id selection preference of the client for resolving
    /// package names and interface instances in command submission and interpretation
    #[prost(string, repeated, tag = "9")]
    pub package_id_selection_preference: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// When true, the response will contain additional details on how the transaction was encoded and hashed
    /// This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
    #[prost(bool, tag = "10")]
    pub verbose_hashing: bool,
    /// Fetches the contract keys into the caches to speed up the command processing.
    /// Should only contain contract keys that are expected to be resolved during interpretation of the commands.
    /// Keys of disclosed contracts do not need prefetching.
    ///
    /// Optional
    #[prost(message, repeated, tag = "15")]
    pub prefetch_contract_keys: ::prost::alloc::vec::Vec<super::PrefetchContractKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareSubmissionResponse {
    /// The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
    /// Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
    #[prost(message, optional, tag = "1")]
    pub prepared_transaction: ::core::option::Option<PreparedTransaction>,
    /// Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
    /// Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
    /// May be removed in future versions
    #[prost(bytes = "vec", tag = "2")]
    pub prepared_transaction_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hashing scheme version used when building the hash
    #[prost(enumeration = "HashingSchemeVersion", tag = "3")]
    pub hashing_scheme_version: i32,
    /// Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
    /// Note that there are no guarantees on the stability of the format or content of this field.
    /// Its content should NOT be parsed and should only be used for troubleshooting purposes.
    #[prost(string, optional, tag = "4")]
    pub hashing_details: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signature {
    #[prost(enumeration = "SignatureFormat", tag = "1")]
    pub format: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The fingerprint/id of the keypair used to create this signature and needed to verify.
    #[prost(string, tag = "3")]
    pub signed_by: ::prost::alloc::string::String,
    /// The signing algorithm specification used to produce this signature
    #[prost(enumeration = "SigningAlgorithmSpec", tag = "4")]
    pub signing_algorithm_spec: i32,
}
/// Signatures provided by a single party
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SinglePartySignatures {
    /// Submitting party
    #[prost(string, tag = "1")]
    pub party: ::prost::alloc::string::String,
    /// Signatures
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<Signature>,
}
/// Additional signatures provided by the submitting parties
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartySignatures {
    /// Additional signatures provided by all individual parties
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<SinglePartySignatures>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteSubmissionRequest {
    /// the prepared transaction
    /// Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
    /// obtained from calling `prepareSubmission`.
    #[prost(message, optional, tag = "1")]
    pub prepared_transaction: ::core::option::Option<PreparedTransaction>,
    /// The party(ies) signatures that authorize the prepared submission to be executed by this node.
    /// Each party can provide one or more signatures..
    /// and one or more parties can sign.
    /// Note that currently, only single party submissions are supported.
    #[prost(message, optional, tag = "2")]
    pub party_signatures: ::core::option::Option<PartySignatures>,
    /// A unique identifier to distinguish completions for different submissions with the same change ID.
    /// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
    /// with the same change ID.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    ///
    /// Required
    #[prost(string, tag = "5")]
    pub submission_id: ::prost::alloc::string::String,
    /// See \[PrepareSubmissionRequest.user_id\]
    #[prost(string, tag = "6")]
    pub user_id: ::prost::alloc::string::String,
    /// The hashing scheme version used when building the hash
    #[prost(enumeration = "HashingSchemeVersion", tag = "7")]
    pub hashing_scheme_version: i32,
    /// If set will influence the chosen ledger effective time but will not result in a submission delay so any override
    /// should be scheduled to executed within the window allowed by synchronizer.
    ///
    /// Optional
    #[prost(message, optional, tag = "8")]
    pub min_ledger_time: ::core::option::Option<MinLedgerTime>,
    /// Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
    /// If omitted, the participant will assume the configured maximum deduplication time.
    #[prost(oneof = "execute_submission_request::DeduplicationPeriod", tags = "3, 4")]
    pub deduplication_period: ::core::option::Option<
        execute_submission_request::DeduplicationPeriod,
    >,
}
/// Nested message and enum types in `ExecuteSubmissionRequest`.
pub mod execute_submission_request {
    /// Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
    /// If omitted, the participant will assume the configured maximum deduplication time.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum DeduplicationPeriod {
        /// Specifies the length of the deduplication period.
        /// It is interpreted relative to the local clock at some point during the submission's processing.
        /// Must be non-negative. Must not exceed the maximum deduplication time.
        #[prost(message, tag = "3")]
        DeduplicationDuration(::prost_types::Duration),
        /// Specifies the start of the deduplication period by a completion stream offset (exclusive).
        /// Must be a valid absolute offset (positive integer).
        #[prost(int64, tag = "4")]
        DeduplicationOffset(i64),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteSubmissionResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinLedgerTime {
    #[prost(oneof = "min_ledger_time::Time", tags = "1, 2")]
    pub time: ::core::option::Option<min_ledger_time::Time>,
}
/// Nested message and enum types in `MinLedgerTime`.
pub mod min_ledger_time {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Time {
        /// Lower bound for the ledger time assigned to the resulting transaction.
        /// The ledger time of a transaction is assigned as part of command interpretation.
        /// Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
        /// and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
        /// The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
        /// If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
        /// by the preparation time, which is also assigned in the "prepare" step (this request),
        /// but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
        /// Must not be set at the same time as min_ledger_time_rel.
        /// Optional
        #[prost(message, tag = "1")]
        MinLedgerTimeAbs(::prost_types::Timestamp),
        /// Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
        /// Must not be set at the same time as min_ledger_time_abs.
        /// Optional
        #[prost(message, tag = "2")]
        MinLedgerTimeRel(::prost_types::Duration),
    }
}
/// *
/// Prepared Transaction Message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreparedTransaction {
    /// Daml Transaction representing the ledger effect if executed. See below
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<DamlTransaction>,
    /// Metadata context necessary to execute the transaction
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
}
/// Transaction Metadata
/// Refer to the hashing documentation for information on how it should be hashed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(message, optional, tag = "2")]
    pub submitter_info: ::core::option::Option<metadata::SubmitterInfo>,
    #[prost(string, tag = "3")]
    pub synchronizer_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub mediator_group: u32,
    #[prost(string, tag = "5")]
    pub transaction_uuid: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub preparation_time: u64,
    #[prost(message, repeated, tag = "7")]
    pub input_contracts: ::prost::alloc::vec::Vec<metadata::InputContract>,
    ///
    /// Where ledger time constraints are imposed during the execution of the contract they will be populated
    /// in the fields below. These are optional because if the transaction does NOT depend on time, these values
    /// do not need to be set.
    /// The final ledger effective time used will be chosen when the command is submitted through the \[execute\] RPC.
    /// If the ledger effective time is outside of any populated min/max bounds then a different transaction
    /// can result, that will cause a confirmation message rejection.
    #[prost(uint64, optional, tag = "9")]
    pub min_ledger_effective_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub max_ledger_effective_time: ::core::option::Option<u64>,
    /// Contextual information needed to process the transaction but not signed, either because it's already indirectly
    /// signed by signing the transaction, or because it doesn't impact the ledger state
    #[prost(message, repeated, tag = "8")]
    pub global_key_mapping: ::prost::alloc::vec::Vec<metadata::GlobalKeyMappingEntry>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubmitterInfo {
        #[prost(string, repeated, tag = "1")]
        pub act_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "2")]
        pub command_id: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GlobalKeyMappingEntry {
        #[prost(message, optional, tag = "1")]
        pub key: ::core::option::Option<super::GlobalKey>,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::super::Value>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputContract {
        #[prost(uint64, tag = "1000")]
        pub created_at: u64,
        #[prost(bytes = "vec", tag = "1002")]
        pub event_blob: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "input_contract::Contract", tags = "1")]
        pub contract: ::core::option::Option<input_contract::Contract>,
    }
    /// Nested message and enum types in `InputContract`.
    pub mod input_contract {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Contract {
            /// When new versions will be added, they will show here
            #[prost(message, tag = "1")]
            V1(super::super::transaction::v1::Create),
        }
    }
}
///
/// Daml Transaction.
/// This represents the effect on the ledger if this transaction is successfully committed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DamlTransaction {
    /// Transaction version, will be >= max(nodes version)
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Root nodes of the transaction
    #[prost(string, repeated, tag = "2")]
    pub roots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of nodes in the transaction
    #[prost(message, repeated, tag = "3")]
    pub nodes: ::prost::alloc::vec::Vec<daml_transaction::Node>,
    /// Node seeds are values associated with certain nodes used for generating cryptographic salts
    #[prost(message, repeated, tag = "4")]
    pub node_seeds: ::prost::alloc::vec::Vec<daml_transaction::NodeSeed>,
}
/// Nested message and enum types in `DamlTransaction`.
pub mod daml_transaction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeSeed {
        #[prost(int32, tag = "1")]
        pub node_id: i32,
        #[prost(bytes = "vec", tag = "2")]
        pub seed: ::prost::alloc::vec::Vec<u8>,
    }
    /// A transaction may contain nodes with different versions.
    /// Each node must be hashed using the hashing algorithm corresponding to its specific version.
    /// \[docs-entry-start: DamlTransaction.Node\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(string, tag = "1")]
        pub node_id: ::prost::alloc::string::String,
        /// Versioned node
        #[prost(oneof = "node::VersionedNode", tags = "1000")]
        pub versioned_node: ::core::option::Option<node::VersionedNode>,
    }
    /// Nested message and enum types in `Node`.
    pub mod node {
        /// Versioned node
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum VersionedNode {
            /// Start at 1000 so we can add more fields before if necessary
            /// When new versions will be added, they will show here
            #[prost(message, tag = "1000")]
            V1(super::super::transaction::v1::Node),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreferredPackageVersionRequest {
    /// The parties whose participants' vetting state should be considered when resolving the preferred package.
    /// Required
    #[prost(string, repeated, tag = "1")]
    pub parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The package-name for which the preferred package should be resolved.
    /// Required
    #[prost(string, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
    /// The synchronizer whose vetting state to use for resolving this query.
    /// If not specified, the vetting state of all the synchronizers the participant is connected to will be used.
    /// Optional
    #[prost(string, tag = "3")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// The timestamp at which the package vetting validity should be computed
    /// on the latest topology snapshot as seen by the participant.
    /// If not provided, the participant's current clock time is used.
    /// Optional
    #[prost(message, optional, tag = "4")]
    pub vetting_valid_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreferredPackageVersionResponse {
    /// Not populated when no preferred package is found
    /// Optional
    #[prost(message, optional, tag = "1")]
    pub package_preference: ::core::option::Option<PackagePreference>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackagePreference {
    /// The package reference of the preferred package.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub package_reference: ::core::option::Option<super::PackageReference>,
    /// The synchronizer for which the preferred package was computed.
    /// If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
    /// Required
    #[prost(string, tag = "2")]
    pub synchronizer_id: ::prost::alloc::string::String,
}
/// \[docs-entry-start: HashingSchemeVersion\]
/// The hashing scheme version used when building the hash of the PreparedTransaction
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashingSchemeVersion {
    Unspecified = 0,
    V2 = 2,
}
impl HashingSchemeVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HASHING_SCHEME_VERSION_UNSPECIFIED",
            Self::V2 => "HASHING_SCHEME_VERSION_V2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASHING_SCHEME_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "HASHING_SCHEME_VERSION_V2" => Some(Self::V2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SigningAlgorithmSpec {
    Unspecified = 0,
    /// EdDSA Signature based on Curve25519 with SHA-512
    /// <http://ed25519.cr.yp.to/>
    Ed25519 = 1,
    /// Elliptic Curve Digital Signature Algorithm with SHA256
    EcDsaSha256 = 2,
    /// Elliptic Curve Digital Signature Algorithm with SHA384
    EcDsaSha384 = 3,
}
impl SigningAlgorithmSpec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNING_ALGORITHM_SPEC_UNSPECIFIED",
            Self::Ed25519 => "SIGNING_ALGORITHM_SPEC_ED25519",
            Self::EcDsaSha256 => "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256",
            Self::EcDsaSha384 => "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNING_ALGORITHM_SPEC_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNING_ALGORITHM_SPEC_ED25519" => Some(Self::Ed25519),
            "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256" => Some(Self::EcDsaSha256),
            "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384" => Some(Self::EcDsaSha384),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureFormat {
    Unspecified = 0,
    /// Signature scheme specific signature format
    /// Legacy format no longer used, except for migrations
    Raw = 1,
    /// ASN.1 + DER-encoding of the `r` and `s` integers, as defined in <https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3>
    /// Used for ECDSA signatures
    Der = 2,
    /// Concatenation of the integers `r || s` in little-endian form, as defined in <https://datatracker.ietf.org/doc/html/rfc8032#section-3.3>
    /// Note that this is different from the format defined in IEEE P1363, which uses concatenation in big-endian form.
    /// Used for EdDSA signatures
    Concat = 3,
    /// Symbolic crypto, must only be used for testing
    Symbolic = 10000,
}
impl SignatureFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNATURE_FORMAT_UNSPECIFIED",
            Self::Raw => "SIGNATURE_FORMAT_RAW",
            Self::Der => "SIGNATURE_FORMAT_DER",
            Self::Concat => "SIGNATURE_FORMAT_CONCAT",
            Self::Symbolic => "SIGNATURE_FORMAT_SYMBOLIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNATURE_FORMAT_RAW" => Some(Self::Raw),
            "SIGNATURE_FORMAT_DER" => Some(Self::Der),
            "SIGNATURE_FORMAT_CONCAT" => Some(Self::Concat),
            "SIGNATURE_FORMAT_SYMBOLIC" => Some(Self::Symbolic),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod interactive_submission_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service allowing interactive construction of command submissions
    ///
    /// The prepare and execute endpoints allow to submit commands in 2-steps:
    ///
    /// 1. prepare transaction from commands,
    /// 2. submit the prepared transaction
    ///
    /// This gives callers the ability to sign the daml transaction with their own signing keys
    #[derive(Debug, Clone)]
    pub struct InteractiveSubmissionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InteractiveSubmissionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InteractiveSubmissionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InteractiveSubmissionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            InteractiveSubmissionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Requires `readAs` scope for the submitting party when LAPI User authorization is enabled
        pub async fn prepare_submission(
            &mut self,
            request: impl tonic::IntoRequest<super::PrepareSubmissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrepareSubmissionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.interactive.InteractiveSubmissionService/PrepareSubmission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.interactive.InteractiveSubmissionService",
                        "PrepareSubmission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn execute_submission(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteSubmissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteSubmissionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.interactive.InteractiveSubmissionService/ExecuteSubmission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.interactive.InteractiveSubmissionService",
                        "ExecuteSubmission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// A preferred package is the highest-versioned package for a provided package-name
        /// that is vetted by all the participants hosting the provided parties.
        ///
        /// Ledger API clients should use this endpoint for constructing command submissions
        /// that are compatible with the provided preferred package, by making informed decisions on:
        /// - which are the compatible packages that can be used to create contracts
        /// - which contract or exercise choice argument version can be used in the command
        /// - which choices can be executed on a template or interface of a contract
        ///
        /// Can be accessed by any Ledger API client with a valid token when Ledger API authorization is enabled.
        ///
        /// Experimental API: this endpoint is not guaranteed to provide backwards compatibility in future releases
        pub async fn get_preferred_package_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPreferredPackageVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPreferredPackageVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.interactive.InteractiveSubmissionService/GetPreferredPackageVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.interactive.InteractiveSubmissionService",
                        "GetPreferredPackageVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
