// This file is @generated by prost-build.
/// Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
///
/// Based on ``ObjectMeta`` meta used in Kubernetes API.
/// See <https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectMeta {
    /// An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
    /// this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
    /// You must not rely on the format of resource version. The participant server might change it without notice.
    /// You can obtain the newest resource version value by issuing a read request.
    /// You may use it for concurrent change detection by passing it back unmodified in an update request.
    /// The participant server will then compare the passed value with the value maintained by the system to determine
    /// if any other updates took place since you had read the resource version.
    /// Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
    /// However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
    /// Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
    /// When creating a new instance of a resource you must leave the resource version empty.
    /// Its value will be populated by the participant server upon successful resource creation.
    /// Optional
    #[prost(string, tag = "6")]
    pub resource_version: ::prost::alloc::string::String,
    /// A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata.
    /// Constraints:
    ///
    /// 1. The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
    /// 2. Keys are composed of an optional prefix segment and a required name segment such that:
    ///
    ///     - key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a '/' (forward slash) character,
    ///     - name segment must have at most 63 characters that are either alphanumeric (\[a-z0-9A-Z\]), or a '.' (dot), '-' (dash) or '_' (underscore);
    ///       and it must start and end with an alphanumeric character.
    ///
    /// 3. Values can be any non-empty strings.
    ///
    /// Keys with empty prefix are reserved for end-users.
    /// Properties set by external tools or internally by the participant server must use non-empty key prefixes.
    /// Duplicate keys are disallowed by the semantics of the protobuf3 maps.
    /// See: <https://developers.google.com/protocol-buffers/docs/proto3#maps>
    /// Annotations may be a part of a modifiable resource.
    /// Use the resource's update RPC to update its annotations.
    /// In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request.
    /// In order to remove an annotation using an update RPC, provide the target annotation's key but set its value to the empty string in the update request.
    /// Optional
    /// Modifiable
    #[prost(map = "string, string", tag = "12")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Users are used to dynamically manage the rights given to Daml applications.
/// They are stored and managed per participant node.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// The user identifier, which must be a non-empty string of at most 128
    /// characters that are either alphanumeric ASCII characters or one of the symbols "@^$.!`-#+'~_|:".
    /// Required
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The primary party as which this user reads and acts by default on the ledger
    /// *provided* it has the corresponding ``CanReadAs(primary_party)`` or
    /// ``CanActAs(primary_party)`` rights.
    /// Ledger API clients SHOULD set this field to a non-empty value for all users to
    /// enable the users to act on the ledger using their own Daml party.
    /// Users for participant administrators MAY have an associated primary party.
    /// Optional,
    /// Modifiable
    #[prost(string, tag = "2")]
    pub primary_party: ::prost::alloc::string::String,
    /// When set, then the user is denied all access to the Ledger API.
    /// Otherwise, the user has access to the Ledger API as per the user's rights.
    /// Optional,
    /// Modifiable
    #[prost(bool, tag = "3")]
    pub is_deactivated: bool,
    /// The metadata of this user.
    /// Note that the ``metadata.resource_version`` tracks changes to the properties described by the ``User`` message and not the user's rights.
    /// Optional,
    /// Modifiable
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ObjectMeta>,
    /// The ID of the identity provider configured by ``Identity Provider Config``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "5")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// A right granted to a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Right {
    /// Required
    #[prost(oneof = "right::Kind", tags = "1, 2, 3, 4, 5")]
    pub kind: ::core::option::Option<right::Kind>,
}
/// Nested message and enum types in `Right`.
pub mod right {
    /// The right to administer the participant node.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticipantAdmin {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CanActAs {
        /// The right to authorize commands for this party.
        #[prost(string, tag = "1")]
        pub party: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CanReadAs {
        /// The right to read ledger data visible to this party.
        #[prost(string, tag = "1")]
        pub party: ::prost::alloc::string::String,
    }
    /// The right to administer the identity provider that the user is assigned to.
    /// It means, being able to manage users and parties that are also assigned
    /// to the same identity provider.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IdentityProviderAdmin {}
    /// The rights of a participant's super reader. Its utility is predominantly for
    /// feeding external tools, such as PQS, continually without the need to change subscriptions
    /// as new parties pop in and out of existence.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CanReadAsAnyParty {}
    /// Required
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The user can administer the participant node.
        #[prost(message, tag = "1")]
        ParticipantAdmin(ParticipantAdmin),
        /// The user can act as a specific party.
        #[prost(message, tag = "2")]
        CanActAs(CanActAs),
        /// The user can read ledger data visible to a specific party.
        #[prost(message, tag = "3")]
        CanReadAs(CanReadAs),
        /// The user can administer users and parties assigned to the same identity provider as the one of the user.
        #[prost(message, tag = "4")]
        IdentityProviderAdmin(IdentityProviderAdmin),
        /// The user can read as any party on a participant
        #[prost(message, tag = "5")]
        CanReadAsAnyParty(CanReadAsAnyParty),
    }
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserRequest {
    /// The user to create.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    /// The rights to be assigned to the user upon creation,
    /// which SHOULD include appropriate rights for the ``user.primary_party``.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserResponse {
    /// Created user.
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserRequest {
    /// The user whose data to retrieve.
    /// If set to empty string (the default), then the data for the authenticated user will be retrieved.
    /// Optional
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserResponse {
    /// Retrieved user.
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserRequest {
    /// The user to update.
    /// Required,
    /// Modifiable
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    /// An update mask specifies how and which properties of the ``User`` message are to be updated.
    /// An update mask consists of a set of update paths.
    /// A valid update path points to a field or a subfield relative to the ``User`` message.
    /// A valid update mask must:
    ///
    /// 1. contain at least one update path,
    /// 2. contain only valid update paths.
    ///
    /// Fields that can be updated are marked as ``Modifiable``.
    /// An update path can also point to a non-``Modifiable`` fields such as 'id' and 'metadata.resource_version'
    /// because they are used:
    ///
    /// 1. to identify the user resource subject to the update,
    /// 2. for concurrent change control.
    ///
    /// Examples of valid update paths: 'primary_party', 'metadata', 'metadata.annotations'.
    /// For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
    /// For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest``.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserResponse {
    /// Updated user
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserRequest {
    /// The user to delete.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// Does not (yet) contain any data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteUserResponse {}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    /// Pagination token to determine the specific page to fetch.
    /// Leave empty to fetch the first page.
    /// Optional
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Maximum number of results to be returned by the server. The server will return no more than that many results, but it might return fewer.
    /// If 0, the server will decide the number of results to be returned.
    /// Optional
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "4")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    /// A subset of users of the participant node that fit into this page.
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    /// Pagination token to retrieve the next page.
    /// Empty, if there are no further results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Add the rights to the set of rights granted to the user.
///
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantUserRightsRequest {
    /// The user to whom to grant rights.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The rights to grant.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "3")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantUserRightsResponse {
    /// The rights that were newly granted by the request.
    #[prost(message, repeated, tag = "1")]
    pub newly_granted_rights: ::prost::alloc::vec::Vec<Right>,
}
/// Remove the rights from the set of rights granted to the user.
///
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeUserRightsRequest {
    /// The user from whom to revoke rights.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The rights to revoke.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "3")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeUserRightsResponse {
    /// The rights that were actually revoked by the request.
    #[prost(message, repeated, tag = "1")]
    pub newly_revoked_rights: ::prost::alloc::vec::Vec<Right>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserRightsRequest {
    /// The user for which to list the rights.
    /// If set to empty string (the default), then the rights for the authenticated user will be listed.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserRightsResponse {
    /// All rights of the user.
    #[prost(message, repeated, tag = "1")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
}
/// Required authorization: ``HasRight(ParticipantAdmin)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserIdentityProviderIdRequest {
    /// User to update
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// Current identity provider ID of the user
    #[prost(string, tag = "2")]
    pub source_identity_provider_id: ::prost::alloc::string::String,
    /// Target identity provider ID of the user
    #[prost(string, tag = "3")]
    pub target_identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateUserIdentityProviderIdResponse {}
/// Generated client implementations.
pub mod user_management_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage users and their rights for interacting with the Ledger API
    /// served by a participant node.
    ///
    /// The authorization rules for its RPCs are specified on the ``<RpcName>Request``
    /// messages as boolean expressions over these facts:
    ///
    /// 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
    /// 2. ``IsAuthenticatedUser(uid)`` denoting whether ``uid`` is the empty string or equal to the id of the authenticated user.
    /// 3. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
    ///    of the authenticated user and the user has an IdentityProviderAdmin right.
    ///
    /// If `user_id` is set to the empty string (the default), then the data for the authenticated user will be retrieved.
    /// If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
    /// If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
    ///
    /// The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
    ///
    /// 1. ``Optional`` denoting the client may leave the field unset when sending a request.
    /// 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
    ///
    /// A user resource consists of:
    ///
    /// 1. a set of properties represented by the ``User`` message,
    /// 2. a set of user rights, where each right is represented by the ``Right`` message.
    ///
    /// A user resource, once it has been created, can be modified.
    /// In order to update the properties represented by the ``User`` message use the ``UpdateUser`` RPC. The only fields that can be modified are those marked as ``Modifiable``.
    /// In order to grant or revoke user rights use ``GrantRights' and ``RevokeRights`` RPCs.
    #[derive(Debug, Clone)]
    pub struct UserManagementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserManagementServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserManagementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserManagementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserManagementServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new user.
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/CreateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "CreateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the user data of a specific user or the authenticated user.
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "GetUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update selected modifiable attribute of a user resource described by the ``User`` message.
        pub async fn update_user(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/UpdateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "UpdateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an existing user and all its rights.
        pub async fn delete_user(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/DeleteUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "DeleteUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all existing users.
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "ListUsers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Grant rights to a user.
        /// Granting rights does not affect the resource version of the corresponding user.
        pub async fn grant_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::GrantUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GrantUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/GrantUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "GrantUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Revoke rights from a user.
        /// Revoking rights does not affect the resource version of the corresponding user.
        pub async fn revoke_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/RevokeUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "RevokeUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List the set of all rights granted to a user.
        pub async fn list_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/ListUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "ListUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the assignment of a user from one IDP to another.
        pub async fn update_user_identity_provider_id(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserIdentityProviderIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserIdentityProviderIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/UpdateUserIdentityProviderId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "UpdateUserIdentityProviderId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListKnownPackagesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKnownPackagesResponse {
    /// The details of all Daml-LF packages known to backing participant.
    /// Required
    #[prost(message, repeated, tag = "1")]
    pub package_details: ::prost::alloc::vec::Vec<PackageDetails>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageDetails {
    /// The identity of the Daml-LF package.
    /// Must be a valid PackageIdString (as describe in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub package_id: ::prost::alloc::string::String,
    /// Size of the package in bytes.
    /// The size of the package is given by the size of the ``daml_lf``
    /// ArchivePayload. See further details in ``daml_lf.proto``.
    /// Required
    #[prost(uint64, tag = "2")]
    pub package_size: u64,
    /// Indicates since when the package is known to the backing participant.
    /// Required
    #[prost(message, optional, tag = "3")]
    pub known_since: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the package as defined by the package metadata
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Version of the package as defined by the package metadata
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadDarFileRequest {
    /// Contains a Daml archive DAR file, which in turn is a jar like zipped
    /// container for ``daml_lf`` archives. See further details in
    /// ``daml_lf.proto``.
    /// Required
    #[prost(bytes = "vec", tag = "1")]
    pub dar_file: ::prost::alloc::vec::Vec<u8>,
    /// Unique submission identifier.
    /// Optional, defaults to a random identifier.
    #[prost(string, tag = "2")]
    pub submission_id: ::prost::alloc::string::String,
}
/// A message that is received when the upload operation succeeded.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UploadDarFileResponse {}
/// Performs the same checks that UploadDarFileRequest would perform, but doesn't
/// upload the DAR.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateDarFileRequest {
    /// Contains a Daml archive DAR file, which in turn is a jar like zipped
    /// container for ``daml_lf`` archives. See further details in
    /// ``daml_lf.proto``.
    /// Required
    #[prost(bytes = "vec", tag = "1")]
    pub dar_file: ::prost::alloc::vec::Vec<u8>,
    /// Unique submission identifier.
    /// Optional, defaults to a random identifier.
    #[prost(string, tag = "2")]
    pub submission_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidateDarFileResponse {}
/// Generated client implementations.
pub mod package_management_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Status: experimental interface, will change before it is deemed production
    /// ready
    ///
    /// Query the Daml-LF packages supported by the ledger participant and upload
    /// DAR files. We use 'backing participant' to refer to this specific participant
    /// in the methods of this API.
    #[derive(Debug, Clone)]
    pub struct PackageManagementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PackageManagementServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PackageManagementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PackageManagementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PackageManagementServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the details of all Daml-LF packages known to the backing participant.
        pub async fn list_known_packages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKnownPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKnownPackagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PackageManagementService/ListKnownPackages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PackageManagementService",
                        "ListKnownPackages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Upload a DAR file to the backing participant.
        /// Depending on the ledger implementation this might also make the package
        /// available on the whole ledger. This call might not be supported by some
        /// ledger implementations. Canton could be an example, where uploading a DAR
        /// is not sufficient to render it usable, it must be activated first.
        /// This call may:
        ///
        /// - Succeed, if the package was successfully uploaded, or if the same package
        ///   was already uploaded before.
        /// - Respond with a gRPC error
        pub async fn upload_dar_file(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadDarFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadDarFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PackageManagementService/UploadDarFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PackageManagementService",
                        "UploadDarFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs the same checks that UploadDarFile call perform, but doesn't
        /// upload the DAR and does not make it available on the whole ledger.
        /// This call may:
        ///
        /// - Succeed if the package is valid
        /// - Respond with a gRPC error if the package is not valid
        pub async fn validate_dar_file(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateDarFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateDarFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PackageManagementService/ValidateDarFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PackageManagementService",
                        "ValidateDarFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PruneRequest {
    /// Inclusive valid absolute offset (positive integer) up to which the ledger is to be pruned.
    /// By default the following data is pruned:
    ///
    /// 1. All normal and divulged contracts that have been archived before
    ///     `prune_up_to`.
    /// 2. All transaction events and completions before `prune_up_to`
    #[prost(int64, tag = "1")]
    pub prune_up_to: i64,
    /// Unique submission identifier.
    /// Optional, defaults to a random identifier, used for logging.
    #[prost(string, tag = "2")]
    pub submission_id: ::prost::alloc::string::String,
    /// Prune all immediately and retroactively divulged contracts created before `prune_up_to`
    /// independent of whether they were archived before `prune_up_to`. Useful to avoid leaking
    /// storage on participant nodes that can see a divulged contract but not its archival.
    ///
    /// Application developers SHOULD write their Daml applications
    /// such that they do not rely on divulged contracts; i.e., no warnings from
    /// using divulged contracts as inputs to transactions are emitted.
    ///
    /// Participant node operators SHOULD set the `prune_all_divulged_contracts` flag to avoid leaking
    /// storage due to accumulating unarchived divulged contracts PROVIDED that:
    ///
    /// 1. no application using this participant node relies on divulgence OR
    /// 2. divulged contracts on which applications rely have been re-divulged after the `prune_up_to` offset.
    #[prost(bool, tag = "3")]
    pub prune_all_divulged_contracts: bool,
}
/// Empty for now, but may contain fields in the future
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PruneResponse {}
/// Generated client implementations.
pub mod participant_pruning_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Prunes/truncates the "oldest" transactions from the participant (the participant Ledger Api Server plus any other
    /// participant-local state) by removing a portion of the ledger in such a way that the set of future, allowed
    /// commands are not affected.
    ///
    /// This enables:
    ///
    /// 1. keeping the "inactive" portion of the ledger to a manageable size and
    /// 2. removing inactive state to honor the right to be forgotten.
    #[derive(Debug, Clone)]
    pub struct ParticipantPruningServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ParticipantPruningServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ParticipantPruningServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ParticipantPruningServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ParticipantPruningServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Prune the ledger specifying the offset before and at which ledger transactions should be removed. Only returns when
        /// the potentially long-running prune request ends successfully or with an error.
        pub async fn prune(
            &mut self,
            request: impl tonic::IntoRequest<super::PruneRequest>,
        ) -> std::result::Result<tonic::Response<super::PruneResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.ParticipantPruningService/Prune",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.ParticipantPruningService",
                        "Prune",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Required authorization: ``HasRight(ParticipantAdmin)``
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetParticipantIdRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParticipantIdResponse {
    /// Identifier of the participant, which SHOULD be globally unique.
    /// Must be a valid LedgerString (as describe in ``value.proto``).
    #[prost(string, tag = "1")]
    pub participant_id: ::prost::alloc::string::String,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPartiesRequest {
    /// The stable, unique identifier of the Daml parties.
    /// Must be valid PartyIdStrings (as described in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "1")]
    pub parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The id of the ``Identity Provider`` whose parties should be retrieved.
    /// Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPartiesResponse {
    /// The details of the requested Daml parties by the participant, if known.
    /// The party details may not be in the same order as requested.
    /// Required
    #[prost(message, repeated, tag = "1")]
    pub party_details: ::prost::alloc::vec::Vec<PartyDetails>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKnownPartiesRequest {
    /// Pagination token to determine the specific page to fetch. Using the token guarantees that parties on a subsequent
    /// page are all lexically greater than the last party on a previous page. Server does not store intermediate results
    /// between calls chained by a series of page tokens. As a consequence, if new parties are being added and a page is
    /// requested twice using the same token, more parties can be returned on the second call.
    /// Leave empty to fetch the first page.
    /// Optional
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Maximum number of results to be returned by the server. The server will return no more than that many results,
    /// but it might return fewer. If the page_size is 0, the server will decide the number of results to be returned.
    /// If the page_size exceeds the maximum supported by the server, an error will be returned. To obtain the server's
    /// maximum consult the PartyManagementFeature descriptor available in the VersionService.
    /// Optional
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The id of the ``Identity Provider`` whose parties should be retrieved.
    /// Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
    #[prost(string, tag = "1")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKnownPartiesResponse {
    /// The details of all Daml parties known by the participant.
    /// Required
    #[prost(message, repeated, tag = "1")]
    pub party_details: ::prost::alloc::vec::Vec<PartyDetails>,
    /// Pagination token to retrieve the next page.
    /// Empty, if there are no further results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocatePartyRequest {
    /// A hint to the participant which party ID to allocate. It can be
    /// ignored.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "1")]
    pub party_id_hint: ::prost::alloc::string::String,
    /// Participant-local metadata to be stored in the ``PartyDetails`` of this newly allocated party.
    /// Optional
    #[prost(message, optional, tag = "3")]
    pub local_metadata: ::core::option::Option<ObjectMeta>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
    #[prost(string, tag = "4")]
    pub identity_provider_id: ::prost::alloc::string::String,
    /// The synchronizer, on which the party should be allocated.
    /// For backwards compatibility, this field may be omitted, if the participant is connected to only one synchronizer.
    /// Otherwise a synchronizer must be specified.
    /// Optional
    #[prost(string, tag = "5")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// The user who will get the act_as rights to the newly allocated party.
    /// If set to an empty string (the default), no user will get rights to the party.
    /// Optional
    #[prost(string, tag = "6")]
    pub user_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocatePartyResponse {
    #[prost(message, optional, tag = "1")]
    pub party_details: ::core::option::Option<PartyDetails>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePartyDetailsRequest {
    /// Party to be updated
    /// Required,
    /// Modifiable
    #[prost(message, optional, tag = "1")]
    pub party_details: ::core::option::Option<PartyDetails>,
    /// An update mask specifies how and which properties of the ``PartyDetails`` message are to be updated.
    /// An update mask consists of a set of update paths.
    /// A valid update path points to a field or a subfield relative to the ``PartyDetails`` message.
    /// A valid update mask must:
    ///
    /// 1. contain at least one update path,
    /// 2. contain only valid update paths.
    ///
    /// Fields that can be updated are marked as ``Modifiable``.
    /// An update path can also point to non-``Modifiable`` fields such as 'party' and 'local_metadata.resource_version'
    /// because they are used:
    ///
    /// 1. to identify the party details resource subject to the update,
    /// 2. for concurrent change control.
    ///
    /// An update path can also point to non-``Modifiable`` fields such as 'is_local'
    /// as long as the values provided in the update request match the server values.
    /// Examples of update paths: 'local_metadata.annotations', 'local_metadata'.
    /// For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
    /// For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdateUserRequest``.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePartyDetailsResponse {
    /// Updated party details
    #[prost(message, optional, tag = "1")]
    pub party_details: ::core::option::Option<PartyDetails>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartyDetails {
    /// The stable unique identifier of a Daml party.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub party: ::prost::alloc::string::String,
    /// true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
    /// Optional
    #[prost(bool, tag = "3")]
    pub is_local: bool,
    /// Participant-local metadata of this party.
    /// Optional,
    /// Modifiable
    #[prost(message, optional, tag = "4")]
    pub local_metadata: ::core::option::Option<ObjectMeta>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, there could be 3 options:
    ///
    /// 1. the party is managed by the default identity provider.
    /// 2. party is not hosted by the participant.
    /// 3. party is hosted by the participant, but is outside of the user's identity provider.
    #[prost(string, tag = "5")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// Required authorization: ``HasRight(ParticipantAdmin)``
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePartyIdentityProviderIdRequest {
    /// Party to update
    #[prost(string, tag = "1")]
    pub party: ::prost::alloc::string::String,
    /// Current identity provider id of the party
    #[prost(string, tag = "2")]
    pub source_identity_provider_id: ::prost::alloc::string::String,
    /// Target identity provider id of the party
    #[prost(string, tag = "3")]
    pub target_identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdatePartyIdentityProviderIdResponse {}
/// Generated client implementations.
pub mod party_management_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service allows inspecting the party management state of the ledger known to the participant
    /// and managing the participant-local party metadata.
    ///
    /// The authorization rules for its RPCs are specified on the ``<RpcName>Request``
    /// messages as boolean expressions over these facts:
    ///
    /// 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
    /// 2. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
    ///    of the authenticated user and the user has an IdentityProviderAdmin right.
    ///
    /// If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
    /// If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
    ///
    /// The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
    ///
    /// 1. ``Optional`` denoting the client may leave the field unset when sending a request.
    /// 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
    ///
    /// A party details resource is described by the ``PartyDetails`` message,
    /// A party details resource, once it has been created, can be modified using the ``UpdatePartyDetails`` RPC.
    /// The only fields that can be modified are those marked as ``Modifiable``.
    #[derive(Debug, Clone)]
    pub struct PartyManagementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PartyManagementServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PartyManagementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PartyManagementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PartyManagementServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Return the identifier of the participant.
        /// All horizontally scaled replicas should return the same id.
        /// daml-on-kv-ledger: returns an identifier supplied on command line at launch time
        /// canton: returns globally unique identifier of the participant
        pub async fn get_participant_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetParticipantIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetParticipantIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/GetParticipantId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "GetParticipantId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the party details of the given parties. Only known parties will be
        /// returned in the list.
        pub async fn get_parties(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPartiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPartiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/GetParties",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "GetParties",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List the parties known by the participant.
        /// The list returned contains parties whose ledger access is facilitated by
        /// the participant and the ones maintained elsewhere.
        pub async fn list_known_parties(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKnownPartiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKnownPartiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/ListKnownParties",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "ListKnownParties",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Allocates a new party on a ledger and adds it to the set managed by the participant.
        /// Caller specifies a party identifier suggestion, the actual identifier
        /// allocated might be different and is implementation specific.
        /// Caller can specify party metadata that is stored locally on the participant.
        /// This call may:
        ///
        /// - Succeed, in which case the actual allocated identifier is visible in
        ///   the response.
        /// - Respond with a gRPC error
        ///
        /// daml-on-kv-ledger: suggestion's uniqueness is checked by the validators in
        /// the consensus layer and call rejected if the identifier is already present.
        /// canton: completely different globally unique identifier is allocated.
        /// Behind the scenes calls to an internal protocol are made. As that protocol
        /// is richer than the surface protocol, the arguments take implicit values
        /// The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space,
        /// colon, minus and underscore limited to 255 chars
        pub async fn allocate_party(
            &mut self,
            request: impl tonic::IntoRequest<super::AllocatePartyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllocatePartyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/AllocateParty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "AllocateParty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update selected modifiable participant-local attributes of a party details resource.
        /// Can update the participant's local information for local parties.
        pub async fn update_party_details(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePartyDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePartyDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/UpdatePartyDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "UpdatePartyDetails",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the assignment of a party from one IDP to another.
        pub async fn update_party_identity_provider_id(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePartyIdentityProviderIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePartyIdentityProviderIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.PartyManagementService/UpdatePartyIdentityProviderId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.PartyManagementService",
                        "UpdatePartyIdentityProviderId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityProviderConfig {
    /// The identity provider identifier
    /// Must be a valid LedgerString (as describe in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub identity_provider_id: ::prost::alloc::string::String,
    /// When set, the callers using JWT tokens issued by this identity provider are denied all access
    /// to the Ledger API.
    /// Optional,
    /// Modifiable
    #[prost(bool, tag = "2")]
    pub is_deactivated: bool,
    /// Specifies the issuer of the JWT token.
    /// The issuer value is a case sensitive URL using the https scheme that contains scheme, host,
    /// and optionally, port number and path components and no query or fragment components.
    /// Required
    /// Modifiable
    #[prost(string, tag = "3")]
    pub issuer: ::prost::alloc::string::String,
    /// The JWKS (JSON Web Key Set) URL.
    /// The Ledger API uses JWKs (JSON Web Keys) from the provided URL to verify that the JWT has been
    /// signed with the loaded JWK. Only RS256 (RSA Signature with SHA-256) signing algorithm is supported.
    /// Required
    /// Modifiable
    #[prost(string, tag = "4")]
    pub jwks_url: ::prost::alloc::string::String,
    /// Specifies the audience of the JWT token.
    /// When set, the callers using JWT tokens issued by this identity provider are allowed to get an access
    /// only if the "aud" claim includes the string specified here
    /// Optional,
    /// Modifiable
    #[prost(string, tag = "5")]
    pub audience: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIdentityProviderConfigRequest {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub identity_provider_config: ::core::option::Option<IdentityProviderConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIdentityProviderConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub identity_provider_config: ::core::option::Option<IdentityProviderConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityProviderConfigRequest {
    /// Required
    #[prost(string, tag = "1")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityProviderConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub identity_provider_config: ::core::option::Option<IdentityProviderConfig>,
}
/// Pagination is not required as the resulting data set is small enough to be returned in a single call
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListIdentityProviderConfigsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIdentityProviderConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub identity_provider_configs: ::prost::alloc::vec::Vec<IdentityProviderConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIdentityProviderConfigRequest {
    /// The identity provider config to update.
    /// Required,
    /// Modifiable
    #[prost(message, optional, tag = "1")]
    pub identity_provider_config: ::core::option::Option<IdentityProviderConfig>,
    /// An update mask specifies how and which properties of the ``IdentityProviderConfig`` message are to be updated.
    /// An update mask consists of a set of update paths.
    /// A valid update path points to a field or a subfield relative to the ``IdentityProviderConfig`` message.
    /// A valid update mask must:
    ///
    /// 1. contain at least one update path,
    /// 2. contain only valid update paths.
    ///
    /// Fields that can be updated are marked as ``Modifiable``.
    /// For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIdentityProviderConfigResponse {
    /// Updated identity provider config
    #[prost(message, optional, tag = "1")]
    pub identity_provider_config: ::core::option::Option<IdentityProviderConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIdentityProviderConfigRequest {
    /// The identity provider config to delete.
    /// Required
    #[prost(string, tag = "1")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// Does not (yet) contain any data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteIdentityProviderConfigResponse {}
/// Generated client implementations.
pub mod identity_provider_config_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Identity Provider Config Service makes it possible for participant node administrators
    /// to setup and manage additional identity providers at runtime.
    ///
    /// This allows using access tokens from identity providers unknown at deployment time. When an identity
    /// provider is configured, independent IDP administrators can manage their own set of parties and users.
    /// Such parties and users have a matching `identity_provider_id` defined and are inaccessible to
    /// administrators from other identity providers. A user will only be authenticated if the corresponding JWT
    /// token is issued by the appropriate identity provider.
    /// Users and parties without `identity_provider_id` defined are assumed to be using the default identity provider,
    /// which is configured statically at the participant node's deployment time.
    ///
    /// The Ledger API uses the "iss" claim of a JWT token to match the token to a specific IDP. If there is no match,
    /// the default IDP is assumed.
    ///
    /// The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
    ///
    /// 1. ``Optional`` denoting the client may leave the field unset when sending a request.
    /// 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
    ///
    /// An identity provider config resource is described by the ``IdentityProviderConfig`` message,
    /// An identity provider config resource, once it has been created, can be modified.
    /// In order to update the properties represented by the ``IdentityProviderConfig`` message use the ``UpdateIdentityProviderConfig`` RPC.
    /// The only fields that can be modified are those marked as ``Modifiable``.
    #[derive(Debug, Clone)]
    pub struct IdentityProviderConfigServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IdentityProviderConfigServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IdentityProviderConfigServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IdentityProviderConfigServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IdentityProviderConfigServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new identity provider configuration.
        /// The request will fail if the maximum allowed number of separate configurations is reached.
        pub async fn create_identity_provider_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIdentityProviderConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIdentityProviderConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.IdentityProviderConfigService/CreateIdentityProviderConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.IdentityProviderConfigService",
                        "CreateIdentityProviderConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the identity provider configuration data by id.
        pub async fn get_identity_provider_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIdentityProviderConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIdentityProviderConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.IdentityProviderConfigService/GetIdentityProviderConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.IdentityProviderConfigService",
                        "GetIdentityProviderConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update selected modifiable attribute of an identity provider config resource described
        /// by the ``IdentityProviderConfig`` message.
        pub async fn update_identity_provider_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIdentityProviderConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIdentityProviderConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.IdentityProviderConfigService/UpdateIdentityProviderConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.IdentityProviderConfigService",
                        "UpdateIdentityProviderConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all existing identity provider configurations.
        pub async fn list_identity_provider_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIdentityProviderConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIdentityProviderConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.IdentityProviderConfigService/ListIdentityProviderConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.IdentityProviderConfigService",
                        "ListIdentityProviderConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an existing identity provider configuration.
        pub async fn delete_identity_provider_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIdentityProviderConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteIdentityProviderConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.IdentityProviderConfigService/DeleteIdentityProviderConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.IdentityProviderConfigService",
                        "DeleteIdentityProviderConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommandStatusRequest {
    /// optional filter by command id
    #[prost(string, tag = "1")]
    pub command_id_prefix: ::prost::alloc::string::String,
    /// optional filter by state
    #[prost(enumeration = "CommandState", tag = "2")]
    pub state: i32,
    /// optional limit of returned statuses, defaults to 100
    #[prost(uint32, tag = "3")]
    pub limit: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommandStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub command_status: ::prost::alloc::vec::Vec<CommandStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandStatus {
    #[prost(message, optional, tag = "1")]
    pub started: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub completed: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub completion: ::core::option::Option<super::Completion>,
    #[prost(enumeration = "CommandState", tag = "4")]
    pub state: i32,
    #[prost(message, repeated, tag = "5")]
    pub commands: ::prost::alloc::vec::Vec<super::Command>,
    #[prost(message, optional, tag = "6")]
    pub request_statistics: ::core::option::Option<RequestStatistics>,
    #[prost(message, optional, tag = "7")]
    pub updates: ::core::option::Option<CommandUpdates>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestStatistics {
    #[prost(uint32, tag = "1")]
    pub envelopes: u32,
    #[prost(uint32, tag = "2")]
    pub request_size: u32,
    #[prost(uint32, tag = "3")]
    pub recipients: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandUpdates {
    #[prost(message, repeated, tag = "1")]
    pub created: ::prost::alloc::vec::Vec<Contract>,
    #[prost(message, repeated, tag = "2")]
    pub archived: ::prost::alloc::vec::Vec<Contract>,
    #[prost(uint32, tag = "3")]
    pub exercised: u32,
    #[prost(uint32, tag = "4")]
    pub fetched: u32,
    #[prost(uint32, tag = "5")]
    pub looked_up_by_key: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contract {
    /// The identifier of the template used to create the contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<super::Identifier>,
    /// The contract's ID
    ///
    /// Required
    #[prost(string, tag = "2")]
    pub contract_id: ::prost::alloc::string::String,
    /// The contract key, if defined
    ///
    /// Optional
    #[prost(message, optional, tag = "3")]
    pub contract_key: ::core::option::Option<super::Value>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandState {
    /// This value acts as wildcard in the queries
    Unspecified = 0,
    Pending = 1,
    Succeeded = 2,
    Failed = 3,
}
impl CommandState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMMAND_STATE_UNSPECIFIED",
            Self::Pending => "COMMAND_STATE_PENDING",
            Self::Succeeded => "COMMAND_STATE_SUCCEEDED",
            Self::Failed => "COMMAND_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMAND_STATE_PENDING" => Some(Self::Pending),
            "COMMAND_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "COMMAND_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod command_inspection_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Status: experimental interface, will change before it is deemed production
    /// ready
    ///
    /// The inspection service provides methods for the ledger administrator
    /// to look under the hood of a running system.
    /// In V2 Ledger API this service is not available.
    #[derive(Debug, Clone)]
    pub struct CommandInspectionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CommandInspectionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CommandInspectionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CommandInspectionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CommandInspectionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inquire about the status of a command.
        /// This service is used for debugging only. The command status is only tracked in memory and is not persisted.
        /// The service can be used to understand the failure status and the structure of a command.
        /// Requires admin privileges
        /// The service is alpha without backward compatibility guarantees.
        pub async fn get_command_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommandStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCommandStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.CommandInspectionService/GetCommandStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.CommandInspectionService",
                        "GetCommandStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
