// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceContext {
    /// <https://www.w3.org/TR/trace-context/>
    #[prost(string, optional, tag = "1")]
    pub traceparent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub tracestate: ::core::option::Option<::prost::alloc::string::String>,
}
/// Encodes values that the ledger accepts as command arguments and emits as contract arguments.
///
/// The values encoding use different classes of non-empty strings as identifiers. Those classes are
/// defined as follows:
///
/// - NameStrings are strings with length <= 1000 that match the regexp ``[A-Za-z\$_][A-Za-z0-9\$_]*``.
/// - PackageIdStrings are strings with length <= 64 that match the regexp ``\[A-Za-z0-9\-_ \]+``.
/// - PartyIdStrings are strings with length <= 255 that match the regexp ``\[A-Za-z0-9:\-_ \]+``.
/// - LedgerStrings are strings with length <= 255 that match the regexp ``\[A-Za-z0-9#:\-_/ \]+``.
/// - UserIdStrings are strings with length <= 128 that match the regexp ``\[a-zA-Z0-9@^$.!`\-#+'~_|:\]+``.
///
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(
        oneof = "value::Sum",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"
    )]
    pub sum: ::core::option::Option<value::Sum>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Sum {
        /// This value is used for example for choices that don't take any arguments.
        #[prost(message, tag = "1")]
        Unit(()),
        /// True or false.
        #[prost(bool, tag = "2")]
        Bool(bool),
        #[prost(sint64, tag = "3")]
        Int64(i64),
        /// Days since the unix epoch. Can go backwards. Limited from
        /// 0001-01-01 to 9999-12-31, also to be compatible with
        /// <https://www.ietf.org/rfc/rfc3339.txt>
        #[prost(int32, tag = "4")]
        Date(i32),
        /// Microseconds since the UNIX epoch. Can go backwards. Fixed
        /// since the vast majority of values will be greater than
        /// 2^28, since currently the number of microseconds since the
        /// epoch is greater than that. Range: 0001-01-01T00:00:00Z to
        /// 9999-12-31T23:59:59.999999Z, so that we can convert to/from
        /// <https://www.ietf.org/rfc/rfc3339.txt>
        #[prost(sfixed64, tag = "5")]
        Timestamp(i64),
        /// A Numeric, that is a decimal value with precision 38 (at most 38 significant digits) and a
        /// scale between 0 and 37 (significant digits on the right of the decimal point).
        /// The field has to match the regex
        ///
        /// .. code-block:: none
        ///
        ///    \[+-\]?\d{1,38}(.\d{0,37})?
        ///
        /// and should be representable by a Numeric without loss of precision.
        #[prost(string, tag = "6")]
        Numeric(::prost::alloc::string::String),
        /// An agent operating on the ledger.
        /// Must be a valid PartyIdString.
        #[prost(string, tag = "7")]
        Party(::prost::alloc::string::String),
        /// A string.
        #[prost(string, tag = "8")]
        Text(::prost::alloc::string::String),
        /// Identifier of an on-ledger contract. Commands which reference an unknown or already archived contract ID will fail.
        /// Must be a valid LedgerString.
        #[prost(string, tag = "9")]
        ContractId(::prost::alloc::string::String),
        /// The Optional type, None or Some
        #[prost(message, tag = "10")]
        Optional(::prost::alloc::boxed::Box<super::Optional>),
        /// Represents a homogeneous list of values.
        #[prost(message, tag = "11")]
        List(super::List),
        /// The TextMap type
        #[prost(message, tag = "12")]
        TextMap(super::TextMap),
        /// The GenMap type
        #[prost(message, tag = "13")]
        GenMap(super::GenMap),
        #[prost(message, tag = "14")]
        Record(super::Record),
        #[prost(message, tag = "15")]
        Variant(::prost::alloc::boxed::Box<super::Variant>),
        /// The Enum type
        #[prost(message, tag = "16")]
        Enum(super::Enum),
    }
}
/// Contains nested values.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Record {
    /// Omitted from the transaction stream when verbose streaming is not enabled.
    /// Optional when submitting commands.
    #[prost(message, optional, tag = "1")]
    pub record_id: ::core::option::Option<Identifier>,
    /// The nested values of the record.
    /// Required
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<RecordField>,
}
/// A named nested value within a record.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordField {
    /// When reading a transaction stream, it's omitted if verbose streaming is not enabled.
    /// When submitting a command, it's optional:
    ///
    /// - if all keys within a single record are present, the order in which fields appear does not matter. however, each key must appear exactly once.
    /// - if any of the keys within a single record are omitted, the order of fields MUST match the order of declaration in the Daml template.
    ///
    /// Must be a valid NameString
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    /// A nested value of a record.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Value>,
}
/// Unique identifier of an entity.
/// Throughout this API, the following terminology is being used:
///
///    - if a Daml package-id is encoded in the package_id field, it is referred to as using a "package-id reference format"
///    - if a Daml package-name is encoded in the package_id field, it is referred to as using a "package-name reference format"
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Identifier {
    /// Generally, the identifier of the Daml package that contains the entity.
    /// When encoding a package-id, it must be a valid PackageIdString.
    ///
    /// The field is overloaded to also be able to contain the package-name of the Daml package.
    /// This is supported if the entity referenced is either an interface or template.
    /// When representing the Daml package-name, the encoding is of form `#<package-name>`
    /// where `#` (not a valid package-id character)
    /// is used as a discriminator for signalling a package-name encoding.
    ///
    /// Required
    #[prost(string, tag = "1")]
    pub package_id: ::prost::alloc::string::String,
    /// The dot-separated module name of the identifier.
    /// Required
    #[prost(string, tag = "2")]
    pub module_name: ::prost::alloc::string::String,
    /// The dot-separated name of the entity (e.g. record, template, ...) within the module.
    /// Required
    #[prost(string, tag = "3")]
    pub entity_name: ::prost::alloc::string::String,
}
/// A value with alternative representations.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variant {
    /// Omitted from the transaction stream when verbose streaming is not enabled.
    /// Optional when submitting commands.
    #[prost(message, optional, tag = "1")]
    pub variant_id: ::core::option::Option<Identifier>,
    /// Determines which of the Variant's alternatives is encoded in this message.
    /// Must be a valid NameString.
    /// Required
    #[prost(string, tag = "2")]
    pub constructor: ::prost::alloc::string::String,
    /// The value encoded within the Variant.
    /// Required
    #[prost(message, optional, boxed, tag = "3")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Value>>,
}
/// A value with finite set of alternative representations.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enum {
    /// Omitted from the transaction stream when verbose streaming is not enabled.
    /// Optional when submitting commands.
    #[prost(message, optional, tag = "1")]
    pub enum_id: ::core::option::Option<Identifier>,
    /// Determines which of the Variant's alternatives is encoded in this message.
    /// Must be a valid NameString.
    /// Required
    #[prost(string, tag = "2")]
    pub constructor: ::prost::alloc::string::String,
}
/// A homogenous collection of values.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct List {
    /// The elements must all be of the same concrete value type.
    /// Optional
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<Value>,
}
/// Corresponds to Java's Optional type, Scala's Option, and Haskell's Maybe.
/// The reason why we need to wrap this in an additional ``message`` is that we
/// need to be able to encode the ``None`` case in the ``Value`` oneof.
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Optional {
    /// optional
    #[prost(message, optional, boxed, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Value>>,
}
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMap {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<text_map::Entry>,
}
/// Nested message and enum types in `TextMap`.
pub mod text_map {
    #[derive(serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::Value>,
    }
}
#[derive(serde::Serialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenMap {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<gen_map::Entry>,
}
/// Nested message and enum types in `GenMap`.
pub mod gen_map {
    #[derive(serde::Serialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(message, optional, tag = "1")]
        pub key: ::core::option::Option<super::Value>,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::Value>,
    }
}
/// Events in transactions can have two primary shapes:
///
/// - ACS delta: events can be CreatedEvent or ArchivedEvent
/// - ledger effects: events can be CreatedEvent or ExercisedEvent
///
/// In the update service the events are restricted to the events
/// visible for the parties specified in the transaction filter. Each
/// event message type below contains a ``witness_parties`` field which
/// indicates the subset of the requested parties that can see the event
/// in question.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(oneof = "event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<event::Event>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// The event as it appeared in the context of its original daml transaction on this participant node.
        /// In particular, the offset, node_id pair of the daml transaction are preserved.
        #[prost(message, tag = "1")]
        Created(super::CreatedEvent),
        #[prost(message, tag = "2")]
        Archived(super::ArchivedEvent),
        #[prost(message, tag = "3")]
        Exercised(super::ExercisedEvent),
    }
}
/// Records that a contract has been created, and choices may now be exercised on it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatedEvent {
    /// The offset of origin, which has contextual meaning, please see description at messages that include a CreatedEvent.
    /// Offsets are managed by the participant nodes.
    /// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
    /// Required, it is a valid absolute offset (positive integer)
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// The position of this event in the originating transaction or reassignment.
    /// The origin has contextual meaning, please see description at messages that include a CreatedEvent.
    /// Node IDs are not necessarily equal across participants,
    /// as these may see different projections/parts of transactions.
    /// Required, must be valid node ID (non-negative integer)
    #[prost(int32, tag = "2")]
    pub node_id: i32,
    /// The ID of the created contract.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub contract_id: ::prost::alloc::string::String,
    /// The template of the created contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "4")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The key of the created contract.
    /// This will be set if and only if ``create_arguments`` is set and ``template_id`` defines a contract key.
    /// Optional
    #[prost(message, optional, tag = "5")]
    pub contract_key: ::core::option::Option<Value>,
    /// The arguments that have been used to create the contract.
    /// Set either:
    ///
    /// - if there was a party, which is in the ``witness_parties`` of this event,
    ///    and for which a ``CumulativeFilter`` exists with the ``template_id`` of this event
    ///    among the ``template_filters``,
    /// - or if there was a party, which is in the ``witness_parties`` of this event,
    ///    and for which a wildcard filter exists (``Filters`` with a ``CumulativeFilter`` of ``WildcardFilter``).
    ///
    /// Optional
    #[prost(message, optional, tag = "6")]
    pub create_arguments: ::core::option::Option<Record>,
    /// Opaque representation of contract create event payload intended for forwarding
    /// to an API server as a contract disclosed as part of a command
    /// submission.
    /// Optional
    #[prost(bytes = "vec", tag = "7")]
    pub created_event_blob: ::prost::alloc::vec::Vec<u8>,
    /// Interface views specified in the transaction filter.
    /// Includes an ``InterfaceView`` for each interface for which there is a ``InterfaceFilter`` with
    ///
    /// - its party in the ``witness_parties`` of this event,
    /// - and which is implemented by the template of this event,
    /// - and which has ``include_interface_view`` set.
    ///
    /// Optional
    #[prost(message, repeated, tag = "8")]
    pub interface_views: ::prost::alloc::vec::Vec<InterfaceView>,
    /// The parties that are notified of this event. When a ``CreatedEvent``
    /// is returned as part of a transaction tree or ledger-effects transaction, this will include all
    /// the parties specified in the ``TransactionFilter`` that are informees
    /// of the event. If served as part of a ACS delta transaction those will
    /// be limited to all parties specified in the ``TransactionFilter`` that
    /// are stakeholders of the contract (i.e. either signatories or observers).
    /// If the ``CreatedEvent`` is returned as part of an AssignedEvent,
    /// ActiveContract or IncompleteUnassigned (so the event is related to
    /// an assignment or unassignment): this will include all parties of the
    /// ``TransactionFilter`` that are stakeholders of the contract.
    ///
    /// The behavior of reading create events visible to parties not hosted
    /// on the participant node serving the Ledger API is undefined. Concretely,
    /// there is neither a guarantee that the participant node will serve all their
    /// create events on the ACS stream, nor is there a guarantee that matching archive
    /// events are delivered for such create events.
    ///
    /// For most clients this is not a problem, as they only read events for parties
    /// that are hosted on the participant node. If you need to read events
    /// for parties that may not be hosted at all times on the participant node,
    /// subscribe to the ``TopologyEvent``s for that party by setting a corresponding
    /// ``UpdateFormat``.  Using these events, query the ACS as-of an offset where the
    /// party is hosted on the participant node, and ignore create events at offsets
    /// where the party is not hosted on the participant node.
    /// Required
    #[prost(string, repeated, tag = "9")]
    pub witness_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The signatories for this contract as specified by the template.
    /// Required
    #[prost(string, repeated, tag = "10")]
    pub signatories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
    /// This field never contains parties that are signatories.
    /// Required
    #[prost(string, repeated, tag = "11")]
    pub observers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ledger effective time of the transaction that created the contract.
    /// Required
    #[prost(message, optional, tag = "12")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The package name of the created contract.
    /// Required
    #[prost(string, tag = "13")]
    pub package_name: ::prost::alloc::string::String,
}
/// View of a create event matched by an interface filter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterfaceView {
    /// The interface implemented by the matched event.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub interface_id: ::core::option::Option<Identifier>,
    /// Whether the view was successfully computed, and if not,
    /// the reason for the error. The error is reported using the same rules
    /// for error codes and messages as the errors returned for API requests.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub view_status: ::core::option::Option<
        super::super::super::super::super::google::rpc::Status,
    >,
    /// The value of the interface's view method on this event.
    /// Set if it was requested in the ``InterfaceFilter`` and it could be
    /// sucessfully computed.
    /// Optional
    #[prost(message, optional, tag = "3")]
    pub view_value: ::core::option::Option<Record>,
}
/// Records that a contract has been archived, and choices may no longer be exercised on it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchivedEvent {
    /// The offset of origin.
    /// Offsets are managed by the participant nodes.
    /// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
    /// Required, it is a valid absolute offset (positive integer)
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// The position of this event in the originating transaction or reassignment.
    /// Node IDs are not necessarily equal across participants,
    /// as these may see different projections/parts of transactions.
    /// Required, must be valid node ID (non-negative integer)
    #[prost(int32, tag = "2")]
    pub node_id: i32,
    /// The ID of the archived contract.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub contract_id: ::prost::alloc::string::String,
    /// The template of the archived contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "4")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The parties that are notified of this event. For an ``ArchivedEvent``,
    /// these are the intersection of the stakeholders of the contract in
    /// question and the parties specified in the ``TransactionFilter``. The
    /// stakeholders are the union of the signatories and the observers of
    /// the contract.
    /// Each one of its elements must be a valid PartyIdString (as described
    /// in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "5")]
    pub witness_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The package name of the contract.
    /// Required
    #[prost(string, tag = "6")]
    pub package_name: ::prost::alloc::string::String,
    /// The interfaces implemented by the target template that have been
    /// matched from the interface filter query.
    /// Populated only in case interface filters with include_interface_view set.
    ///
    /// If defined, the identifier uses the package-id reference format.
    ///
    /// Optional
    #[prost(message, repeated, tag = "7")]
    pub implemented_interfaces: ::prost::alloc::vec::Vec<Identifier>,
}
/// Records that a choice has been exercised on a target contract.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExercisedEvent {
    /// The offset of origin.
    /// Offsets are managed by the participant nodes.
    /// Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
    /// Required, it is a valid absolute offset (positive integer)
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// The position of this event in the originating transaction or reassignment.
    /// Node IDs are not necessarily equal across participants,
    /// as these may see different projections/parts of transactions.
    /// Required, must be valid node ID (non-negative integer)
    #[prost(int32, tag = "2")]
    pub node_id: i32,
    /// The ID of the target contract.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub contract_id: ::prost::alloc::string::String,
    /// The template of the target contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "4")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The interface where the choice is defined, if inherited.
    /// If defined, the identifier uses the package-id reference format.
    ///
    /// Optional
    #[prost(message, optional, tag = "5")]
    pub interface_id: ::core::option::Option<Identifier>,
    /// The choice that was exercised on the target contract.
    /// Must be a valid NameString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "6")]
    pub choice: ::prost::alloc::string::String,
    /// The argument of the exercised choice.
    /// Required
    #[prost(message, optional, tag = "7")]
    pub choice_argument: ::core::option::Option<Value>,
    /// The parties that exercised the choice.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "8")]
    pub acting_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, the target contract may no longer be exercised.
    /// Required
    #[prost(bool, tag = "9")]
    pub consuming: bool,
    /// The parties that are notified of this event. The witnesses of an exercise
    /// node will depend on whether the exercise was consuming or not.
    /// If consuming, the witnesses are the union of the stakeholders and
    /// the actors.
    /// If not consuming, the witnesses are the union of the signatories and
    /// the actors. Note that the actors might not necessarily be observers
    /// and thus signatories. This is the case when the controllers of a
    /// choice are specified using "flexible controllers", using the
    /// ``choice ... controller`` syntax, and said controllers are not
    /// explicitly marked as observers.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "10")]
    pub witness_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of
    /// this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this
    /// node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily
    /// filtered, it is only possible to determine if a node is in a consequent subtree or not.
    /// Required
    #[prost(int32, tag = "11")]
    pub last_descendant_node_id: i32,
    /// The result of exercising the choice.
    /// Required
    #[prost(message, optional, tag = "12")]
    pub exercise_result: ::core::option::Option<Value>,
    /// The package name of the contract.
    /// Required
    #[prost(string, tag = "13")]
    pub package_name: ::prost::alloc::string::String,
    /// If the event is consuming, the interfaces implemented by the target template that have been
    /// matched from the interface filter query.
    /// Populated only in case interface filters with include_interface_view set.
    ///
    /// The identifier uses the package-id reference format.
    ///
    /// Optional
    #[prost(message, repeated, tag = "14")]
    pub implemented_interfaces: ::prost::alloc::vec::Vec<Identifier>,
}
/// The union of a set of template filters, interface filters, or a wildcard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filters {
    /// Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
    /// template or wildcard filter means additional events that will match the query.
    /// The impact of include_interface_view and include_created_event_blob fields in the filters will
    /// also be accumulated.
    /// A template or an interface SHOULD NOT appear twice in the accumulative field.
    /// A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
    /// Optional, if no ``CumulativeFilter`` defined, the default of a single ``WildcardFilter`` with
    /// include_created_event_blob unset is used.
    #[prost(message, repeated, tag = "1")]
    pub cumulative: ::prost::alloc::vec::Vec<CumulativeFilter>,
}
/// A filter that matches all contracts that are either an instance of one of
/// the ``template_filters`` or that match one of the ``interface_filters``.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CumulativeFilter {
    #[prost(oneof = "cumulative_filter::IdentifierFilter", tags = "1, 2, 3")]
    pub identifier_filter: ::core::option::Option<cumulative_filter::IdentifierFilter>,
}
/// Nested message and enum types in `CumulativeFilter`.
pub mod cumulative_filter {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdentifierFilter {
        /// A wildcard filter that matches all templates
        /// Optional
        #[prost(message, tag = "1")]
        WildcardFilter(super::WildcardFilter),
        /// Include an ``InterfaceView`` for every ``InterfaceFilter`` matching a contract.
        /// The ``InterfaceFilter`` instances MUST each use a unique ``interface_id``.
        /// Optional
        #[prost(message, tag = "2")]
        InterfaceFilter(super::InterfaceFilter),
        /// A template for which the data will be included in the
        /// ``create_arguments`` of a matching ``CreatedEvent``.
        /// If a contract is simultaneously selected by a template filter and one or more interface filters,
        /// the corresponding ``include_created_event_blob`` are consolidated using an OR operation.
        /// Optional
        #[prost(message, tag = "3")]
        TemplateFilter(super::TemplateFilter),
    }
}
/// This filter matches all templates.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WildcardFilter {
    /// Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
    /// Use this to access the contract create event payload in your API client
    /// for submitting it as a disclosed contract with future commands.
    /// Optional
    #[prost(bool, tag = "1")]
    pub include_created_event_blob: bool,
}
/// This filter matches contracts that implement a specific interface.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterfaceFilter {
    /// The interface that a matching contract must implement.
    /// The ``interface_id`` needs to be valid: corresponding interface should be defined in
    /// one of the available packages at the time of the query.
    /// Both package-name and package-id reference formats for the identifier are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub interface_id: ::core::option::Option<Identifier>,
    /// Whether to include the interface view on the contract in the returned ``CreatedEvent``.
    /// Use this to access contract data in a uniform manner in your API client.
    /// Optional
    #[prost(bool, tag = "2")]
    pub include_interface_view: bool,
    /// Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
    /// Use this to access the contract create event payload in your API client
    /// for submitting it as a disclosed contract with future commands.
    /// Optional
    #[prost(bool, tag = "3")]
    pub include_created_event_blob: bool,
}
/// This filter matches contracts of a specific template.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateFilter {
    /// A template for which the payload should be included in the response.
    /// The ``template_id`` needs to be valid: corresponding template should be defined in
    /// one of the available packages at the time of the query.
    /// Both package-name and package-id reference formats for the identifier are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
    /// Use this to access the contract event payload in your API client
    /// for submitting it as a disclosed contract with future commands.
    /// Optional
    #[prost(bool, tag = "2")]
    pub include_created_event_blob: bool,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
/// Used both for filtering create and archive events as well as for filtering transaction trees.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFilter {
    /// Each key must be a valid PartyIdString (as described in ``value.proto``).
    /// The interpretation of the filter depends on the transaction-shape being filtered:
    ///
    /// 1. For **transaction trees** (used in GetUpdateTreesResponse for backwards compatibility) all party keys used as
    ///     wildcard filters, and all subtrees whose root has one of the listed parties as an informee are returned.
    ///     If there are ``CumulativeFilter``s, those will control returned ``CreatedEvent`` fields where applicable, but will
    ///     not be used for template/interface filtering.
    /// 2. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
    ///     the listed parties and match the per-party filter.
    /// 3. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
    ///     stakeholders include at least one of the listed parties and match the per-party filter.
    ///
    /// Required
    #[prost(map = "string, message", tag = "1")]
    pub filters_by_party: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Filters,
    >,
    /// Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
    /// with the per-party filter as described above.
    #[prost(message, optional, tag = "2")]
    pub filters_for_any_party: ::core::option::Option<Filters>,
}
/// A format for events which defines both which events should be included
/// and what data should be computed and included for them.
///
/// Note that some of the filtering behavior depends on the `TransactionShape`,
/// which is expected to be specified alongside usages of `EventFormat`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventFormat {
    /// Each key must be a valid PartyIdString (as described in ``value.proto``).
    /// The interpretation of the filter depends on the transaction-shape being filtered:
    ///
    /// 1. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
    ///     the listed parties and match the per-party filter.
    /// 2. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
    ///     stakeholders include at least one of the listed parties and match the per-party filter.
    ///
    /// Optional
    #[prost(map = "string, message", tag = "1")]
    pub filters_by_party: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Filters,
    >,
    /// Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
    /// with the per-party filter as described above.
    /// Optional
    #[prost(message, optional, tag = "2")]
    pub filters_for_any_party: ::core::option::Option<Filters>,
    /// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
    /// In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
    /// Optional
    #[prost(bool, tag = "3")]
    pub verbose: bool,
}
/// A format that specifies what events to include in Daml transactions
/// and what data to compute and include for them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFormat {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub event_format: ::core::option::Option<EventFormat>,
    /// What transaction shape to use for interpreting the filters of the event format.
    /// Required
    #[prost(enumeration = "TransactionShape", tag = "2")]
    pub transaction_shape: i32,
}
/// A format specifying which topology transactions to include and how to render them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopologyFormat {
    /// Include participant authorization topology events in streams.
    /// Optional, if unset no participant authorization topology events are emitted in the stream.
    #[prost(message, optional, tag = "1")]
    pub include_participant_authorization_events: ::core::option::Option<
        ParticipantAuthorizationTopologyFormat,
    >,
}
/// A format specifying which participant authorization topology transactions to include and how to render them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParticipantAuthorizationTopologyFormat {
    /// List of parties for which the topology transactions should be sent.
    /// Empty means: for all parties.
    #[prost(string, repeated, tag = "1")]
    pub parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A format specifying what updates to include and how to render them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFormat {
    /// Include Daml transactions in streams.
    /// Optional, if unset, no transactions are emitted in the stream.
    #[prost(message, optional, tag = "1")]
    pub include_transactions: ::core::option::Option<TransactionFormat>,
    /// Include (un)assignments in the stream.
    /// The events in the result take the shape TRANSACTION_SHAPE_ACS_DELTA.
    /// Optional, if unset, no (un)assignments are emitted in the stream.
    #[prost(message, optional, tag = "2")]
    pub include_reassignments: ::core::option::Option<EventFormat>,
    /// Include topology events in streams.
    /// Optional, if unset no topology events are emitted in the stream.
    #[prost(message, optional, tag = "3")]
    pub include_topology_events: ::core::option::Option<TopologyFormat>,
}
/// Event shape for Transactions.
/// Shapes are exclusive and only one of them can be defined in queries.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionShape {
    /// Following official proto3 convention, not intended for actual use.
    Unspecified = 0,
    /// Transaction shape that is sufficient to maintain an accurate ACS view.
    /// The field witness_parties in events are populated as stakeholders, transaction filter will apply accordingly.
    /// This translates to create and archive events.
    AcsDelta = 1,
    /// Transaction shape that allows maintaining an ACS and also conveys detailed information about
    /// all exercises.
    /// The field witness_parties in events are populated as cumulative informees, transaction filter will apply accordingly.
    /// This translates to create, consuming exercise and non-consuming exercise.
    LedgerEffects = 2,
}
impl TransactionShape {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_SHAPE_UNSPECIFIED",
            Self::AcsDelta => "TRANSACTION_SHAPE_ACS_DELTA",
            Self::LedgerEffects => "TRANSACTION_SHAPE_LEDGER_EFFECTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_SHAPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_SHAPE_ACS_DELTA" => Some(Self::AcsDelta),
            "TRANSACTION_SHAPE_LEDGER_EFFECTS" => Some(Self::LedgerEffects),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsByContractIdRequest {
    /// The contract id being queried.
    /// Required
    #[prost(string, tag = "1")]
    pub contract_id: ::prost::alloc::string::String,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// The parties whose events the client expects to see.
    /// The events associated with the contract id will only be returned if the requesting parties includes
    /// at least one party that is a stakeholder of the event. For a definition of stakeholders see
    /// <https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders>
    /// Optional, if some parties specified, event_format needs to be unset.
    #[prost(string, repeated, tag = "2")]
    pub requesting_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Format of the events in the result, the presentation will be of TRANSACTION_SHAPE_ACS_DELTA.
    /// Optional for backwards compatibility, defaults to an EventFormat where:
    ///
    /// - filters_by_party is a template-wildcard filter for all requesting_parties
    /// - filters_for_any_party is unset
    /// - verbose is set
    #[prost(message, optional, tag = "3")]
    pub event_format: ::core::option::Option<EventFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsByContractIdResponse {
    /// The create event for the contract with the ``contract_id`` given in the request
    /// provided it exists and has not yet been pruned.
    /// Optional
    #[prost(message, optional, tag = "1")]
    pub created: ::core::option::Option<Created>,
    /// The archive event for the contract with the ``contract_id`` given in the request
    /// provided such an archive event exists and it has not yet been pruned.
    /// Optional
    #[prost(message, optional, tag = "2")]
    pub archived: ::core::option::Option<Archived>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Created {
    /// Required
    /// The event as it appeared in the context of its original update (i.e. daml transaction or
    /// reassignment) on this participant node. You can use its offset and node_id to find the
    /// corresponding update and the node within it.
    #[prost(message, optional, tag = "1")]
    pub created_event: ::core::option::Option<CreatedEvent>,
    /// The synchronizer which sequenced the creation of the contract
    /// Required
    #[prost(string, tag = "2")]
    pub synchronizer_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Archived {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub archived_event: ::core::option::Option<ArchivedEvent>,
    /// Required
    /// The synchronizer which sequenced the archival of the contract
    #[prost(string, tag = "2")]
    pub synchronizer_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod event_query_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query events by contract id.
    ///
    /// Note that querying by contract key is not (yet) supported, as contract keys
    /// are not supported (yet) in multi-synchronizer scenarios.
    #[derive(Debug, Clone)]
    pub struct EventQueryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EventQueryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EventQueryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EventQueryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EventQueryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get the create and the consuming exercise event for the contract with the provided ID.
        /// No events will be returned for contracts that have been pruned because they
        /// have already been archived before the latest pruning offset.
        /// If the contract cannot be found for the request, or all the contract-events are filtered, a CONTRACT_EVENTS_NOT_FOUND error will be raised.
        pub async fn get_events_by_contract_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventsByContractIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEventsByContractIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.EventQueryService/GetEventsByContractId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.EventQueryService",
                        "GetEventsByContractId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPackagesResponse {
    /// The IDs of all Daml-LF packages supported by the server.
    /// Each element must be a valid PackageIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "1")]
    pub package_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPackageResponse {
    /// The hash function we use to calculate the hash.
    /// Required
    #[prost(enumeration = "HashFunction", tag = "1")]
    pub hash_function: i32,
    /// Contains a ``daml_lf`` ArchivePayload. See further details in ``daml_lf.proto``.
    /// Required
    #[prost(bytes = "vec", tag = "2")]
    pub archive_payload: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the archive payload, can also used as a ``package_id``.
    /// Must be a valid PackageIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub hash: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPackageStatusResponse {
    /// The status of the package.
    #[prost(enumeration = "PackageStatus", tag = "1")]
    pub package_status: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListPackagesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPackageRequest {
    /// The ID of the requested package.
    /// Must be a valid PackageIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub package_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPackageStatusRequest {
    /// The ID of the requested package.
    /// Must be a valid PackageIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub package_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PackageStatus {
    /// The server is not aware of such a package.
    Unspecified = 0,
    /// The server is able to execute Daml commands operating on this package.
    Registered = 1,
}
impl PackageStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PACKAGE_STATUS_UNSPECIFIED",
            Self::Registered => "PACKAGE_STATUS_REGISTERED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PACKAGE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PACKAGE_STATUS_REGISTERED" => Some(Self::Registered),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashFunction {
    Sha256 = 0,
}
impl HashFunction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Sha256 => "HASH_FUNCTION_SHA256",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_FUNCTION_SHA256" => Some(Self::Sha256),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod package_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to query the Daml-LF packages that are supported by the server.
    #[derive(Debug, Clone)]
    pub struct PackageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PackageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PackageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PackageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PackageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the identifiers of all supported packages.
        pub async fn list_packages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPackagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.PackageService/ListPackages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.PackageService",
                        "ListPackages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the contents of a single package.
        pub async fn get_package(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPackageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.PackageService/GetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.PackageService",
                        "GetPackage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the status of a single package.
        pub async fn get_package_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPackageStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPackageStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.PackageService/GetPackageStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.PackageService",
                        "GetPackageStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Complete view of an on-ledger reassignment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reassignment {
    /// Assigned by the server. Useful for correlating logs.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "2")]
    pub command_id: ::prost::alloc::string::String,
    /// The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "3")]
    pub workflow_id: ::prost::alloc::string::String,
    /// The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
    /// Required, must be a valid absolute offset (positive integer).
    #[prost(int64, tag = "4")]
    pub offset: i64,
    /// The collection of reassignment events. Required.
    #[prost(message, repeated, tag = "5")]
    pub events: ::prost::alloc::vec::Vec<ReassignmentEvent>,
    /// Optional; ledger API trace context
    ///
    /// The trace context transported in this message corresponds to the trace context supplied
    /// by the client application in a HTTP2 header of the original command submission.
    /// We typically use a header to transfer this type of information. Here we use message
    /// body, because it is used in gRPC streams which do not support per message headers.
    /// This field will be populated with the trace context contained in the original submission.
    /// If that was not provided, a unique ledger-api-server generated trace context will be used
    /// instead.
    #[prost(message, optional, tag = "6")]
    pub trace_context: ::core::option::Option<TraceContext>,
    /// The time at which the reassignment was recorded. The record time refers to the source/target
    /// synchronizer for an unassign/assign event respectively.
    /// Required
    #[prost(message, optional, tag = "7")]
    pub record_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReassignmentEvent {
    #[prost(oneof = "reassignment_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<reassignment_event::Event>,
}
/// Nested message and enum types in `ReassignmentEvent`.
pub mod reassignment_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Unassigned(super::UnassignedEvent),
        #[prost(message, tag = "2")]
        Assigned(super::AssignedEvent),
    }
}
/// Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnassignedEvent {
    /// The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
    /// For one contract the (unassign_id, source synchronizer) pair is unique.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub unassign_id: ::prost::alloc::string::String,
    /// The ID of the reassigned contract.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "2")]
    pub contract_id: ::prost::alloc::string::String,
    /// The template of the reassigned contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "3")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The ID of the source synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    /// The ID of the target synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "5")]
    pub target: ::prost::alloc::string::String,
    /// Party on whose behalf the unassign command was executed.
    /// Empty if the unassignment happened offline via the repair service.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "6")]
    pub submitter: ::prost::alloc::string::String,
    /// Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
    /// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
    /// equals zero.
    /// Required
    #[prost(uint64, tag = "7")]
    pub reassignment_counter: u64,
    /// Assignment exclusivity
    /// Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
    /// Defined for reassigning participants.
    /// Optional
    #[prost(message, optional, tag = "8")]
    pub assignment_exclusivity: ::core::option::Option<::prost_types::Timestamp>,
    /// The parties that are notified of this event.
    /// Required
    #[prost(string, repeated, tag = "9")]
    pub witness_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The package name of the contract.
    /// Required
    #[prost(string, tag = "10")]
    pub package_name: ::prost::alloc::string::String,
    /// The offset of origin.
    /// Offsets are managed by the participant nodes.
    /// Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
    /// Required, it is a valid absolute offset (positive integer)
    #[prost(int64, tag = "11")]
    pub offset: i64,
    /// The position of this event in the originating reassignment.
    /// Node IDs are not necessarily equal across participants,
    /// as these may see different projections/parts of reassignments.
    /// Required, must be valid node ID (non-negative integer)
    #[prost(int32, tag = "12")]
    pub node_id: i32,
}
/// Records that a contract has been assigned, and it can be used on the target synchronizer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignedEvent {
    /// The ID of the source synchronizer.
    /// Must be a valid synchronizer id.
    /// Required
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// The ID of the target synchronizer.
    /// Must be a valid synchronizer id.
    /// Required
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    /// The ID from the unassigned event.
    /// For correlation capabilities.
    /// For one contract the (unassign_id, source synchronizer) pair is unique.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub unassign_id: ::prost::alloc::string::String,
    /// Party on whose behalf the assign command was executed.
    /// Empty if the assignment happened offline via the repair service.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "4")]
    pub submitter: ::prost::alloc::string::String,
    /// Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
    /// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
    /// equals zero.
    /// Required
    #[prost(uint64, tag = "5")]
    pub reassignment_counter: u64,
    /// Required
    /// The offset of this event refers to the offset of the assignment,
    /// while the node_id is the index of within the batch.
    #[prost(message, optional, tag = "6")]
    pub created_event: ::core::option::Option<CreatedEvent>,
}
/// If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
/// the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
/// Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
/// migration is not concerned with incomplete (un)assignments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveContractsRequest {
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// Templates to include in the served snapshot, per party.
    /// Optional, if specified event_format must be unset, if not specified event_format must be set.
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<TransactionFilter>,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
    /// In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
    /// Optional, if specified event_format must be unset.
    #[prost(bool, tag = "2")]
    pub verbose: bool,
    /// The offset at which the snapshot of the active contracts will be computed.
    /// Must be no greater than the current ledger end offset.
    /// Must be greater than or equal to the last pruning offset.
    /// Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
    /// If zero, the empty set will be returned.
    #[prost(int64, tag = "3")]
    pub active_at_offset: i64,
    /// Format of the contract_entries in the result. In case of CreatedEvent the presentation will be of
    /// TRANSACTION_SHAPE_ACS_DELTA.
    /// Optional for backwards compatibility, defaults to an EventFormat where:
    ///
    /// - filters_by_party is the filter.filters_by_party from this request
    /// - filters_for_any_party is the filter.filters_for_any_party from this request
    /// - verbose is the verbose field from this request
    #[prost(message, optional, tag = "4")]
    pub event_format: ::core::option::Option<EventFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveContractsResponse {
    /// The workflow ID used in command submission which corresponds to the contract_entry. Only set if
    /// the ``workflow_id`` for the command was set.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    /// For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
    /// the state of one contract in the snapshot.
    /// A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
    /// that is hosted on the synchronizer at the time of the event and the party satisfies the
    /// ``TransactionFilter`` in the query.
    #[prost(oneof = "get_active_contracts_response::ContractEntry", tags = "2, 3, 4")]
    pub contract_entry: ::core::option::Option<
        get_active_contracts_response::ContractEntry,
    >,
}
/// Nested message and enum types in `GetActiveContractsResponse`.
pub mod get_active_contracts_response {
    /// For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
    /// the state of one contract in the snapshot.
    /// A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
    /// that is hosted on the synchronizer at the time of the event and the party satisfies the
    /// ``TransactionFilter`` in the query.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ContractEntry {
        /// The contract is active on the assigned synchronizer, meaning: there was an activation event on the given synchronizer (
        /// created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same
        /// synchronizer, until the active_at_offset.
        /// Since activeness is defined as a per synchronizer concept, it is possible, that a contract is active on one
        /// synchronizer, but already archived on another.
        /// There will be one such message for each synchronizer the contract is active on.
        #[prost(message, tag = "2")]
        ActiveContract(super::ActiveContract),
        /// Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding
        /// assigned event before or at the active_at_offset.
        #[prost(message, tag = "3")]
        IncompleteUnassigned(super::IncompleteUnassigned),
        /// Important: this message is not indicating that the contract is active on the target synchronizer!
        /// Included iff the assigned event was before or at the active_at_offset, but there was no corresponding
        /// unassigned event before or at the active_at_offset.
        #[prost(message, tag = "4")]
        IncompleteAssigned(super::IncompleteAssigned),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveContract {
    /// Required
    /// The event as it appeared in the context of its last update (i.e. daml transaction or
    /// reassignment). In particular, the last offset, node_id pair is preserved.
    /// The last update is the most recent update created or assigned this contract on synchronizer_id synchronizer.
    /// The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
    /// for lookups.
    #[prost(message, optional, tag = "1")]
    pub created_event: ::core::option::Option<CreatedEvent>,
    /// A valid synchronizer id
    /// Required
    #[prost(string, tag = "2")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
    /// with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
    /// equals zero.
    /// This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
    /// before the active_at_offset.
    /// Required
    #[prost(uint64, tag = "3")]
    pub reassignment_counter: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncompleteUnassigned {
    /// Required
    /// The event as it appeared in the context of its last activation update (i.e. daml transaction or
    /// reassignment). In particular, the last activation offset, node_id pair is preserved.
    /// The last activation update is the most recent update created or assigned this contract on synchronizer_id synchronizer before
    /// the unassigned_event.
    /// The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
    /// for lookups.
    #[prost(message, optional, tag = "1")]
    pub created_event: ::core::option::Option<CreatedEvent>,
    /// Required
    #[prost(message, optional, tag = "2")]
    pub unassigned_event: ::core::option::Option<UnassignedEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncompleteAssigned {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub assigned_event: ::core::option::Option<AssignedEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedSynchronizersRequest {
    /// The party of interest
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub party: ::prost::alloc::string::String,
    /// The id of a participant whose mapping of a party to connected synchronizers is requested.
    /// Must be a valid participant-id retrieved through a prior call to getParticipantId.
    /// Defaults to the participant id of the host participant.
    /// Optional
    #[prost(string, tag = "2")]
    pub participant_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedSynchronizersResponse {
    #[prost(message, repeated, tag = "1")]
    pub connected_synchronizers: ::prost::alloc::vec::Vec<
        get_connected_synchronizers_response::ConnectedSynchronizer,
    >,
}
/// Nested message and enum types in `GetConnectedSynchronizersResponse`.
pub mod get_connected_synchronizers_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConnectedSynchronizer {
        /// The alias of the synchronizer
        /// Required
        #[prost(string, tag = "1")]
        pub synchronizer_alias: ::prost::alloc::string::String,
        /// The ID of the synchronizer
        /// Required
        #[prost(string, tag = "2")]
        pub synchronizer_id: ::prost::alloc::string::String,
        /// The permission on the synchronizer
        /// Required
        #[prost(enumeration = "super::ParticipantPermission", tag = "3")]
        pub permission: i32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLedgerEndRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLedgerEndResponse {
    /// It will always be a non-negative integer.
    /// If zero, the participant view of the ledger is empty.
    /// If positive, the absolute offset of the ledger as viewed by the participant.
    #[prost(int64, tag = "1")]
    pub offset: i64,
}
/// Empty for now, but may contain fields in the future.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestPrunedOffsetsRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestPrunedOffsetsResponse {
    /// It will always be a non-negative integer.
    /// If positive, the absolute offset up to which the ledger has been pruned,
    /// disregarding the state of all divulged contracts pruning.
    /// If zero, the ledger has not been pruned yet.
    #[prost(int64, tag = "1")]
    pub participant_pruned_up_to_inclusive: i64,
    /// It will always be a non-negative integer.
    /// If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
    /// It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
    /// For more details about all divulged events pruning,
    /// see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
    /// If zero, the divulged events have not been pruned yet.
    #[prost(int64, tag = "2")]
    pub all_divulged_contracts_pruned_up_to_inclusive: i64,
}
/// Enum indicating the permission level that the participant has for the party
/// whose connected synchronizers are being listed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParticipantPermission {
    Unspecified = 0,
    Submission = 1,
    /// participant can only confirm transactions
    Confirmation = 2,
    /// participant can only observe transactions
    Observation = 3,
}
impl ParticipantPermission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PARTICIPANT_PERMISSION_UNSPECIFIED",
            Self::Submission => "PARTICIPANT_PERMISSION_SUBMISSION",
            Self::Confirmation => "PARTICIPANT_PERMISSION_CONFIRMATION",
            Self::Observation => "PARTICIPANT_PERMISSION_OBSERVATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTICIPANT_PERMISSION_UNSPECIFIED" => Some(Self::Unspecified),
            "PARTICIPANT_PERMISSION_SUBMISSION" => Some(Self::Submission),
            "PARTICIPANT_PERMISSION_CONFIRMATION" => Some(Self::Confirmation),
            "PARTICIPANT_PERMISSION_OBSERVATION" => Some(Self::Observation),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod state_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to get state from the ledger.
    #[derive(Debug, Clone)]
    pub struct StateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StateServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns a stream of the snapshot of the active contracts and incomplete (un)assignments at a ledger offset.
        /// If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken.
        /// Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service.
        /// Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
        pub async fn get_active_contracts(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActiveContractsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetActiveContractsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.StateService/GetActiveContracts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.StateService",
                        "GetActiveContracts",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get the list of connected synchronizers at the time of the query.
        pub async fn get_connected_synchronizers(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectedSynchronizersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConnectedSynchronizersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.StateService/GetConnectedSynchronizers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.StateService",
                        "GetConnectedSynchronizers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the current ledger end.
        /// Subscriptions started with the returned offset will serve events after this RPC was called.
        pub async fn get_ledger_end(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLedgerEndRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLedgerEndResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.StateService/GetLedgerEnd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.StateService",
                        "GetLedgerEnd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest successfully pruned ledger offsets
        pub async fn get_latest_pruned_offsets(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLatestPrunedOffsetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLatestPrunedOffsetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.StateService/GetLatestPrunedOffsets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.StateService",
                        "GetLatestPrunedOffsets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopologyTransaction {
    /// Assigned by the server. Useful for correlating logs.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
    /// Required, it is a valid absolute offset (positive integer).
    #[prost(int64, tag = "2")]
    pub offset: i64,
    /// A valid synchronizer id.
    /// Identifies the synchronizer that synchronized the topology transaction.
    /// Required
    #[prost(string, tag = "3")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// The time at which the changes in the topology transaction become effective. There is a small delay between a
    /// topology transaction being sequenced and the changes it contains becoming effective. Topology transactions appear
    /// in order relative to a synchronizer based on their effective time rather than their sequencing time.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub record_time: ::core::option::Option<::prost_types::Timestamp>,
    /// A non-empty list of topology events.
    /// Required
    #[prost(message, repeated, tag = "5")]
    pub events: ::prost::alloc::vec::Vec<TopologyEvent>,
    /// Optional; ledger API trace context
    ///
    /// The trace context transported in this message corresponds to the trace context supplied
    /// by the client application in a HTTP2 header of the original command submission.
    /// We typically use a header to transfer this type of information. Here we use message
    /// body, because it is used in gRPC streams which do not support per message headers.
    /// This field will be populated with the trace context contained in the original submission.
    /// If that was not provided, a unique ledger-api-server generated trace context will be used
    /// instead.
    #[prost(message, optional, tag = "6")]
    pub trace_context: ::core::option::Option<TraceContext>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopologyEvent {
    #[prost(oneof = "topology_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<topology_event::Event>,
}
/// Nested message and enum types in `TopologyEvent`.
pub mod topology_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        ParticipantAuthorizationChanged(super::ParticipantAuthorizationChanged),
        #[prost(message, tag = "2")]
        ParticipantAuthorizationRevoked(super::ParticipantAuthorizationRevoked),
        #[prost(message, tag = "3")]
        ParticipantAuthorizationAdded(super::ParticipantAuthorizationAdded),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParticipantAuthorizationAdded {
    /// Required
    #[prost(string, tag = "1")]
    pub party_id: ::prost::alloc::string::String,
    /// Required
    #[prost(string, tag = "2")]
    pub participant_id: ::prost::alloc::string::String,
    /// Required
    #[prost(enumeration = "ParticipantPermission", tag = "3")]
    pub participant_permission: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParticipantAuthorizationChanged {
    /// Required
    #[prost(string, tag = "1")]
    pub party_id: ::prost::alloc::string::String,
    /// Required
    #[prost(string, tag = "2")]
    pub participant_id: ::prost::alloc::string::String,
    /// Required
    #[prost(enumeration = "ParticipantPermission", tag = "3")]
    pub participant_permission: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParticipantAuthorizationRevoked {
    /// Required
    #[prost(string, tag = "1")]
    pub party_id: ::prost::alloc::string::String,
    /// Required
    #[prost(string, tag = "2")]
    pub participant_id: ::prost::alloc::string::String,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
/// Each tree event message type below contains a ``witness_parties`` field which
/// indicates the subset of the requested parties that can see the event
/// in question.
///
/// Note that transaction trees might contain events with
/// _no_ witness parties, which were included simply because they were
/// children of events which have witnesses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeEvent {
    #[prost(oneof = "tree_event::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<tree_event::Kind>,
}
/// Nested message and enum types in `TreeEvent`.
pub mod tree_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The event as it appeared in the context of its original daml transaction on this participant node.
        /// In particular, the offset, node_id pair of the daml transaction are preserved.
        #[prost(message, tag = "1")]
        Created(super::CreatedEvent),
        #[prost(message, tag = "2")]
        Exercised(super::ExercisedEvent),
    }
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
/// Complete view of an on-ledger transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionTree {
    /// Assigned by the server. Useful for correlating logs.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "2")]
    pub command_id: ::prost::alloc::string::String,
    /// The workflow ID used in command submission. Only set if the ``workflow_id`` for the command was set.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "3")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Ledger effective time.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub effective_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
    /// Required, it is a valid absolute offset (positive integer).
    #[prost(int64, tag = "5")]
    pub offset: i64,
    /// Changes to the ledger that were caused by this transaction. Nodes of the transaction tree.
    /// Each key must be a valid node ID (non-negative integer).
    /// Required
    #[prost(map = "int32, message", tag = "6")]
    pub events_by_id: ::std::collections::HashMap<i32, TreeEvent>,
    /// A valid synchronizer id.
    /// Identifies the synchronizer that synchronized the transaction.
    /// Required
    #[prost(string, tag = "7")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// Optional; ledger API trace context
    ///
    /// The trace context transported in this message corresponds to the trace context supplied
    /// by the client application in a HTTP2 header of the original command submission.
    /// We typically use a header to transfer this type of information. Here we use message
    /// body, because it is used in gRPC streams which do not support per message headers.
    /// This field will be populated with the trace context contained in the original submission.
    /// If that was not provided, a unique ledger-api-server generated trace context will be used
    /// instead.
    #[prost(message, optional, tag = "8")]
    pub trace_context: ::core::option::Option<TraceContext>,
    /// The time at which the transaction was recorded. The record time refers to the synchronizer
    /// which synchronized the transaction.
    /// Required
    #[prost(message, optional, tag = "9")]
    pub record_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Filtered view of an on-ledger transaction's create and archive events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// Assigned by the server. Useful for correlating logs.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "2")]
    pub command_id: ::prost::alloc::string::String,
    /// The workflow ID used in command submission.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "3")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Ledger effective time.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub effective_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The collection of events.
    /// Contains:
    ///
    /// - ``CreatedEvent`` or ``ArchivedEvent`` in case of ACS_DELTA transaction shape
    /// - ``CreatedEvent`` or ``ExercisedEvent`` in case of LEDGER_EFFECTS transaction shape
    ///
    /// Required
    #[prost(message, repeated, tag = "5")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    /// The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
    /// Required, it is a valid absolute offset (positive integer).
    #[prost(int64, tag = "6")]
    pub offset: i64,
    /// A valid synchronizer id.
    /// Identifies the synchronizer that synchronized the transaction.
    /// Required
    #[prost(string, tag = "7")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// Optional; ledger API trace context
    ///
    /// The trace context transported in this message corresponds to the trace context supplied
    /// by the client application in a HTTP2 header of the original command submission.
    /// We typically use a header to transfer this type of information. Here we use message
    /// body, because it is used in gRPC streams which do not support per message headers.
    /// This field will be populated with the trace context contained in the original submission.
    /// If that was not provided, a unique ledger-api-server generated trace context will be used
    /// instead.
    #[prost(message, optional, tag = "8")]
    pub trace_context: ::core::option::Option<TraceContext>,
    /// The time at which the transaction was recorded. The record time refers to the synchronizer
    /// which synchronized the transaction.
    /// Required
    #[prost(message, optional, tag = "9")]
    pub record_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// See the feature message definitions for descriptions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentalFeatures {
    #[prost(message, optional, tag = "1")]
    pub static_time: ::core::option::Option<ExperimentalStaticTime>,
    #[prost(message, optional, tag = "2")]
    pub command_inspection_service: ::core::option::Option<
        ExperimentalCommandInspectionService,
    >,
}
/// Ledger is in the static time mode and exposes a time service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentalStaticTime {
    #[prost(bool, tag = "1")]
    pub supported: bool,
}
/// Whether the Ledger API supports command inspection service
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentalCommandInspectionService {
    #[prost(bool, tag = "1")]
    pub supported: bool,
}
/// Whether the Ledger API supports party events
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentalPartyTopologyEvents {
    #[prost(bool, tag = "1")]
    pub supported: bool,
}
/// OffsetCheckpoints may be used to:
///
/// - detect time out of commands.
/// - provide an offset which can be used to restart consumption.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OffsetCheckpoint {
    /// The participant's offset, the details of the offset field are described in ``community/ledger-api/README.md``.
    /// Required, must be a valid absolute offset (positive integer).
    #[prost(int64, tag = "1")]
    pub offset: i64,
    #[prost(message, repeated, tag = "2")]
    pub synchronizer_times: ::prost::alloc::vec::Vec<SynchronizerTime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynchronizerTime {
    /// The id of the synchronizer.
    /// Required
    #[prost(string, tag = "1")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub record_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A completion represents the status of a submitted command on the ledger: it can be successful or failed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Completion {
    /// The ID of the succeeded or failed command.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub command_id: ::prost::alloc::string::String,
    /// Identifies the exact type of the error.
    /// It uses the same format of conveying error details as it is used for the RPC responses of the APIs.
    /// Optional
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<
        super::super::super::super::super::google::rpc::Status,
    >,
    /// The update_id of the transaction or reassignment that resulted from the command with command_id.
    /// Only set for successfully executed commands.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    #[prost(string, tag = "3")]
    pub update_id: ::prost::alloc::string::String,
    /// The user-id that was used for the submission, as described in ``commands.proto``.
    /// Must be a valid UserIdString (as described in ``value.proto``).
    /// Optional for historic completions where this data is not available.
    #[prost(string, tag = "4")]
    pub user_id: ::prost::alloc::string::String,
    /// The set of parties on whose behalf the commands were executed.
    /// Contains the ``act_as`` parties from ``commands.proto``
    /// filtered to the requesting parties in CompletionStreamRequest.
    /// The order of the parties need not be the same as in the submission.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Optional for historic completions where this data is not available.
    #[prost(string, repeated, tag = "5")]
    pub act_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The submission ID this completion refers to, as described in ``commands.proto``.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "6")]
    pub submission_id: ::prost::alloc::string::String,
    /// Optional; ledger API trace context
    ///
    /// The trace context transported in this message corresponds to the trace context supplied
    /// by the client application in a HTTP2 header of the original command submission.
    /// We typically use a header to transfer this type of information. Here we use message
    /// body, because it is used in gRPC streams which do not support per message headers.
    /// This field will be populated with the trace context contained in the original submission.
    /// If that was not provided, a unique ledger-api-server generated trace context will be used
    /// instead.
    #[prost(message, optional, tag = "9")]
    pub trace_context: ::core::option::Option<TraceContext>,
    /// May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time.
    /// Required, must be a valid absolute offset (positive integer).
    #[prost(int64, tag = "10")]
    pub offset: i64,
    /// The synchronizer along with its record time.
    /// The synchronizer id provided, in case of
    ///
    /// - successful/failed transactions: identifies the synchronizer of the transaction
    /// - for successful/failed unassign commands: identifies the source synchronizer
    /// - for successful/failed assign commands: identifies the target synchronizer
    ///
    /// Required
    #[prost(message, optional, tag = "11")]
    pub synchronizer_time: ::core::option::Option<SynchronizerTime>,
    /// The actual deduplication window used for the submission, which is derived from
    /// ``Commands.deduplication_period``. The ledger may convert the deduplication period into other
    /// descriptions and extend the period in implementation-specified ways.
    ///
    /// Used to audit the deduplication guarantee described in ``commands.proto``.
    ///
    /// Optional; the deduplication guarantee applies even if the completion omits this field.
    #[prost(oneof = "completion::DeduplicationPeriod", tags = "7, 8")]
    pub deduplication_period: ::core::option::Option<completion::DeduplicationPeriod>,
}
/// Nested message and enum types in `Completion`.
pub mod completion {
    /// The actual deduplication window used for the submission, which is derived from
    /// ``Commands.deduplication_period``. The ledger may convert the deduplication period into other
    /// descriptions and extend the period in implementation-specified ways.
    ///
    /// Used to audit the deduplication guarantee described in ``commands.proto``.
    ///
    /// Optional; the deduplication guarantee applies even if the completion omits this field.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum DeduplicationPeriod {
        /// Specifies the start of the deduplication period by a completion stream offset (exclusive).
        ///
        /// Must be a valid absolute offset (positive integer) or participant begin (zero).
        #[prost(int64, tag = "7")]
        DeduplicationOffset(i64),
        /// Specifies the length of the deduplication period.
        /// It is measured in record time of completions.
        ///
        /// Must be non-negative.
        #[prost(message, tag = "8")]
        DeduplicationDuration(::prost_types::Duration),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLedgerApiVersionRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLedgerApiVersionResponse {
    /// The version of the ledger API.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// The features supported by this Ledger API endpoint.
    ///
    /// Daml applications CAN use the feature descriptor on top of
    /// version constraints on the Ledger API version to determine
    /// whether a given Ledger API endpoint supports the features
    /// required to run the application.
    ///
    /// See the feature descriptions themselves for the relation between
    /// Ledger API versions and feature presence.
    #[prost(message, optional, tag = "2")]
    pub features: ::core::option::Option<FeaturesDescriptor>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeaturesDescriptor {
    /// Features under development or features that are used
    /// for ledger implementation testing purposes only.
    ///
    /// Daml applications SHOULD not depend on these in production.
    #[prost(message, optional, tag = "1")]
    pub experimental: ::core::option::Option<ExperimentalFeatures>,
    /// If set, then the Ledger API server supports user management.
    /// It is recommended that clients query this field to gracefully adjust their behavior for
    /// ledgers that do not support user management.
    #[prost(message, optional, tag = "2")]
    pub user_management: ::core::option::Option<UserManagementFeature>,
    /// If set, then the Ledger API server supports party management configurability.
    /// It is recommended that clients query this field to gracefully adjust their behavior to
    /// maximum party page size.
    #[prost(message, optional, tag = "3")]
    pub party_management: ::core::option::Option<PartyManagementFeature>,
    /// It contains the timeouts related to the periodic offset checkpoint emission
    #[prost(message, optional, tag = "4")]
    pub offset_checkpoint: ::core::option::Option<OffsetCheckpointFeature>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserManagementFeature {
    /// Whether the Ledger API server provides the user management service.
    #[prost(bool, tag = "1")]
    pub supported: bool,
    /// The maximum number of rights that can be assigned to a single user.
    /// Servers MUST support at least 100 rights per user.
    /// A value of 0 means that the server enforces no rights per user limit.
    #[prost(int32, tag = "2")]
    pub max_rights_per_user: i32,
    /// The maximum number of users the server can return in a single response (page).
    /// Servers MUST support at least a 100 users per page.
    /// A value of 0 means that the server enforces no page size limit.
    #[prost(int32, tag = "3")]
    pub max_users_page_size: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartyManagementFeature {
    /// The maximum number of parties the server can return in a single response (page).
    #[prost(int32, tag = "1")]
    pub max_parties_page_size: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OffsetCheckpointFeature {
    /// The maximum delay to emmit a new OffsetCheckpoint if it exists
    #[prost(message, optional, tag = "1")]
    pub max_offset_checkpoint_emission_delay: ::core::option::Option<
        ::prost_types::Duration,
    >,
}
/// Generated client implementations.
pub mod version_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to retrieve information about the ledger API version
    #[derive(Debug, Clone)]
    pub struct VersionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VersionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VersionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VersionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            VersionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Read the Ledger API version
        pub async fn get_ledger_api_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLedgerApiVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLedgerApiVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.VersionService/GetLedgerApiVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.VersionService",
                        "GetLedgerApiVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageReference {
    /// Required
    #[prost(string, tag = "1")]
    pub package_id: ::prost::alloc::string::String,
    /// Required
    #[prost(string, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
    /// Required
    #[prost(string, tag = "3")]
    pub package_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReassignmentCommands {
    /// Identifier of the on-ledger workflow that this command is a part of.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Uniquely identifies the participant user that issued the command.
    /// Must be a valid UserIdString (as described in ``value.proto``).
    /// Required unless authentication is used with a user token.
    /// In that case, the token's user-id will be used for the request's user_id.
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Uniquely identifies the command.
    /// The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
    /// The change ID can be used for matching the intended ledger changes with all their completions.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub command_id: ::prost::alloc::string::String,
    /// Party on whose behalf the command should be executed.
    /// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
    /// to act on behalf of the given party.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "4")]
    pub submitter: ::prost::alloc::string::String,
    /// A unique identifier to distinguish completions for different submissions with the same change ID.
    /// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
    /// with the same change ID.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    ///
    /// If omitted, the participant or the committer may set a value of their choice.
    /// Optional
    #[prost(string, tag = "5")]
    pub submission_id: ::prost::alloc::string::String,
    /// Individual elements of this reassignment. Must be non-empty.
    #[prost(message, repeated, tag = "6")]
    pub commands: ::prost::alloc::vec::Vec<ReassignmentCommand>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReassignmentCommand {
    #[prost(oneof = "reassignment_command::Command", tags = "1, 2")]
    pub command: ::core::option::Option<reassignment_command::Command>,
}
/// Nested message and enum types in `ReassignmentCommand`.
pub mod reassignment_command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        #[prost(message, tag = "1")]
        UnassignCommand(super::UnassignCommand),
        #[prost(message, tag = "2")]
        AssignCommand(super::AssignCommand),
    }
}
/// Unassign a contract
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnassignCommand {
    /// The ID of the contract the client wants to unassign.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub contract_id: ::prost::alloc::string::String,
    /// The ID of the source synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The ID of the target synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
}
/// Assign a contract
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignCommand {
    /// The ID from the unassigned event to be completed by this assignment.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub unassign_id: ::prost::alloc::string::String,
    /// The ID of the source synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The ID of the target synchronizer
    /// Must be a valid synchronizer id
    /// Required
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionStreamRequest {
    /// Only completions of commands submitted with the same user_id will be visible in the stream.
    /// Must be a valid UserIdString (as described in ``value.proto``).
    /// Required unless authentication is used with a user token.
    /// In that case, the token's user-id will be used for the request's user_id.
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// Non-empty list of parties whose data should be included.
    /// The stream shows only completions of commands for which at least one of the ``act_as`` parties is in the given set of parties.
    /// Must be a valid PartyIdString (as described in ``value.proto``).
    /// Required
    #[prost(string, repeated, tag = "2")]
    pub parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// This optional field indicates the minimum offset for completions. This can be used to resume an earlier completion stream.
    /// If not set the ledger uses the ledger begin offset instead.
    /// If specified, it must be a valid absolute offset (positive integer) or zero (ledger begin offset).
    /// If the ledger has been pruned, this parameter must be specified and greater than the pruning offset.
    #[prost(int64, tag = "3")]
    pub begin_exclusive: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionStreamResponse {
    #[prost(oneof = "completion_stream_response::CompletionResponse", tags = "1, 2")]
    pub completion_response: ::core::option::Option<
        completion_stream_response::CompletionResponse,
    >,
}
/// Nested message and enum types in `CompletionStreamResponse`.
pub mod completion_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CompletionResponse {
        #[prost(message, tag = "1")]
        Completion(super::Completion),
        #[prost(message, tag = "2")]
        OffsetCheckpoint(super::OffsetCheckpoint),
    }
}
/// Generated client implementations.
pub mod command_completion_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to observe the status of their submissions.
    /// Commands may be submitted via the Command Submission Service.
    /// The on-ledger effects of their submissions are disclosed by the Update Service.
    ///
    /// Commands may fail in 2 distinct manners:
    ///
    /// 1. Failure communicated synchronously in the gRPC error of the submission.
    /// 2. Failure communicated asynchronously in a Completion, see ``completion.proto``.
    ///
    /// Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY
    /// choose to produce a completion event for a rejection of a duplicate command.
    ///
    /// Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful.
    /// Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.
    #[derive(Debug, Clone)]
    pub struct CommandCompletionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CommandCompletionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CommandCompletionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CommandCompletionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CommandCompletionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to command completion events.
        pub async fn completion_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::CompletionStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CompletionStreamResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandCompletionService/CompletionStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandCompletionService",
                        "CompletionStream",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// A command can either create a new contract or exercise a choice on an existing contract.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 4, 3")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        #[prost(message, tag = "1")]
        Create(super::CreateCommand),
        #[prost(message, tag = "2")]
        Exercise(super::ExerciseCommand),
        #[prost(message, tag = "4")]
        ExerciseByKey(super::ExerciseByKeyCommand),
        #[prost(message, tag = "3")]
        CreateAndExercise(super::CreateAndExerciseCommand),
    }
}
/// Create a new contract instance based on a template.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCommand {
    /// The template of contract the client wants to create.
    /// Both package-name and package-id reference identifier formats for the template-id are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The arguments required for creating a contract from this template.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub create_arguments: ::core::option::Option<Record>,
}
/// Exercise a choice on an existing contract.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExerciseCommand {
    /// The template of contract the client wants to exercise.
    /// Both package-name and package-id reference identifier formats for the template-id are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The ID of the contract the client wants to exercise upon.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "2")]
    pub contract_id: ::prost::alloc::string::String,
    /// The name of the choice the client wants to exercise.
    /// Must be a valid NameString (as described in ``value.proto``)
    /// Required
    #[prost(string, tag = "3")]
    pub choice: ::prost::alloc::string::String,
    /// The argument for this choice.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub choice_argument: ::core::option::Option<Value>,
}
/// Exercise a choice on an existing contract specified by its key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExerciseByKeyCommand {
    /// The template of contract the client wants to exercise.
    /// Both package-name and package-id reference identifier formats for the template-id are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The key of the contract the client wants to exercise upon.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub contract_key: ::core::option::Option<Value>,
    /// The name of the choice the client wants to exercise.
    /// Must be a valid NameString (as described in ``value.proto``)
    /// Required
    #[prost(string, tag = "3")]
    pub choice: ::prost::alloc::string::String,
    /// The argument for this choice.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub choice_argument: ::core::option::Option<Value>,
}
/// Create a contract and exercise a choice on it in the same transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAndExerciseCommand {
    /// The template of the contract the client wants to create.
    /// Both package-name and package-id reference identifier formats for the template-id are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The arguments required for creating a contract from this template.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub create_arguments: ::core::option::Option<Record>,
    /// The name of the choice the client wants to exercise.
    /// Must be a valid NameString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub choice: ::prost::alloc::string::String,
    /// The argument for this choice.
    /// Required
    #[prost(message, optional, tag = "4")]
    pub choice_argument: ::core::option::Option<Value>,
}
/// An additional contract that is used to resolve
/// contract & contract key lookups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisclosedContract {
    /// The template id of the contract.
    /// The identifier uses the package-id reference format.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The contract id
    /// Required
    #[prost(string, tag = "2")]
    pub contract_id: ::prost::alloc::string::String,
    /// Opaque byte string containing the complete payload required by the Daml engine
    /// to reconstruct a contract not known to the receiving participant.
    /// Required
    #[prost(bytes = "vec", tag = "3")]
    pub created_event_blob: ::prost::alloc::vec::Vec<u8>,
    /// The ID of the synchronizer where the contract is currently assigned
    /// Optional
    #[prost(string, tag = "4")]
    pub synchronizer_id: ::prost::alloc::string::String,
}
/// A composite command that groups multiple commands together.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Commands {
    /// Identifier of the on-ledger workflow that this command is a part of.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Optional
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Uniquely identifies the participant user that issued the command.
    /// Must be a valid UserIdString (as described in ``value.proto``).
    /// Required unless authentication is used with a user token.
    /// In that case, the token's user-id will be used for the request's user_id.
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Uniquely identifies the command.
    /// The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
    /// where act_as is interpreted as a set of party names.
    /// The change ID can be used for matching the intended ledger changes with all their completions.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "3")]
    pub command_id: ::prost::alloc::string::String,
    /// Individual elements of this atomic command. Must be non-empty.
    /// Required
    #[prost(message, repeated, tag = "4")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
    /// Lower bound for the ledger time assigned to the resulting transaction.
    /// Note: The ledger time of a transaction is assigned as part of command interpretation.
    /// Use this property if you expect that command interpretation will take a considerate amount of time, such that by
    /// the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
    /// Must not be set at the same time as min_ledger_time_rel.
    /// Optional
    #[prost(message, optional, tag = "7")]
    pub min_ledger_time_abs: ::core::option::Option<::prost_types::Timestamp>,
    /// Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server.
    /// Must not be set at the same time as min_ledger_time_abs.
    /// Optional
    #[prost(message, optional, tag = "8")]
    pub min_ledger_time_rel: ::core::option::Option<::prost_types::Duration>,
    /// Set of parties on whose behalf the command should be executed.
    /// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
    /// to act on behalf of each of the given parties.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Required, must be non-empty.
    #[prost(string, repeated, tag = "9")]
    pub act_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
    /// This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
    /// Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
    /// node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
    /// one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
    /// rules for fetch operations.
    /// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
    /// to read contract data on behalf of each of the given parties.
    /// Optional
    #[prost(string, repeated, tag = "10")]
    pub read_as: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A unique identifier to distinguish completions for different submissions with the same change ID.
    /// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
    /// with the same change ID.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    ///
    /// If omitted, the participant or the committer may set a value of their choice.
    /// Optional
    #[prost(string, tag = "11")]
    pub submission_id: ::prost::alloc::string::String,
    /// Additional contracts used to resolve contract & contract key lookups.
    /// Optional
    #[prost(message, repeated, tag = "12")]
    pub disclosed_contracts: ::prost::alloc::vec::Vec<DisclosedContract>,
    /// Must be a valid synchronizer id
    /// Optional
    #[prost(string, tag = "13")]
    pub synchronizer_id: ::prost::alloc::string::String,
    /// The package-id selection preference of the client for resolving
    /// package names and interface instances in command submission and interpretation
    #[prost(string, repeated, tag = "14")]
    pub package_id_selection_preference: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Fetches the contract keys into the caches to speed up the command processing.
    /// Should only contain contract keys that are expected to be resolved during interpretation of the commands.
    /// Keys of disclosed contracts do not need prefetching.
    ///
    /// Optional
    #[prost(message, repeated, tag = "15")]
    pub prefetch_contract_keys: ::prost::alloc::vec::Vec<PrefetchContractKey>,
    /// Specifies the deduplication period for the change ID.
    /// If omitted, the participant will assume the configured maximum deduplication time.
    #[prost(oneof = "commands::DeduplicationPeriod", tags = "5, 6")]
    pub deduplication_period: ::core::option::Option<commands::DeduplicationPeriod>,
}
/// Nested message and enum types in `Commands`.
pub mod commands {
    /// Specifies the deduplication period for the change ID.
    /// If omitted, the participant will assume the configured maximum deduplication time.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum DeduplicationPeriod {
        /// Specifies the length of the deduplication period.
        /// It is interpreted relative to the local clock at some point during the submission's processing.
        /// Must be non-negative. Must not exceed the maximum deduplication time.
        #[prost(message, tag = "5")]
        DeduplicationDuration(::prost_types::Duration),
        /// Specifies the start of the deduplication period by a completion stream offset (exclusive).
        /// Must be a valid absolute offset (positive integer) or participant begin (zero).
        #[prost(int64, tag = "6")]
        DeduplicationOffset(i64),
    }
}
/// Preload contracts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrefetchContractKey {
    /// The template of contract the client wants to prefetch.
    /// Both package-name and package-id reference identifier formats for the template-id are supported.
    /// Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
    ///
    /// Required
    #[prost(message, optional, tag = "1")]
    pub template_id: ::core::option::Option<Identifier>,
    /// The key of the contract the client wants to prefetch.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub contract_key: ::core::option::Option<Value>,
}
/// These commands are executed as a single atomic transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitRequest {
    /// The commands to be submitted.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub commands: ::core::option::Option<Commands>,
}
/// These commands are executed as a single atomic transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitForTransactionRequest {
    /// The commands to be submitted.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub commands: ::core::option::Option<Commands>,
    /// If no ``transaction_format`` is provided, a default will be used where ``transaction_shape`` is set to
    /// TRANSACTION_SHAPE_ACS_DELTA, ``event_format`` is defined with ``filters_by_party`` containing wildcard-template
    /// filter for all original ``act_as`` and ``read_as`` parties and the ``verbose`` flag is set.
    /// Optional
    #[prost(message, optional, tag = "2")]
    pub transaction_format: ::core::option::Option<TransactionFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitResponse {
    /// The id of the transaction that resulted from the submitted command.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The details of the offset field are described in ``community/ledger-api/README.md``.
    /// Required
    #[prost(int64, tag = "2")]
    pub completion_offset: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitForTransactionResponse {
    /// The transaction that resulted from the submitted command.
    /// The transaction might contain no events (request conditions result in filtering out all of them).
    /// Required
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitForTransactionTreeResponse {
    /// The transaction tree that resulted from the submitted command.
    /// The transaction might contain no events (request conditions result in filtering out all of them).
    /// Required
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionTree>,
}
/// This reassignment is executed as a single atomic update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitForReassignmentRequest {
    /// The reassignment commands to be submitted.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub reassignment_commands: ::core::option::Option<ReassignmentCommands>,
    /// Optional
    /// If no event_format provided, the result will contain no events.
    /// The events in the result, will take shape TRANSACTION_SHAPE_ACS_DELTA.
    #[prost(message, optional, tag = "2")]
    pub event_format: ::core::option::Option<EventFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitAndWaitForReassignmentResponse {
    /// The reassignment that resulted from the submitted reassignment command.
    /// The reassignment might contain no events (request conditions result in filtering out all of them).
    /// Required
    #[prost(message, optional, tag = "1")]
    pub reassignment: ::core::option::Option<Reassignment>,
}
/// Generated client implementations.
pub mod command_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Command Service is able to correlate submitted commands with completion data, identify timeouts, and return contextual
    /// information with each tracking result. This supports the implementation of stateless clients.
    ///
    /// Note that submitted commands generally produce completion events as well, even in case a command gets rejected.
    /// For example, the participant SHOULD produce a completion event for a rejection of a duplicate command.
    #[derive(Debug, Clone)]
    pub struct CommandServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CommandServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CommandServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CommandServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CommandServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submits a single composite command and waits for its result.
        /// Propagates the gRPC error of failed submissions including Daml interpretation errors.
        pub async fn submit_and_wait(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitAndWaitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitAndWaitResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandService/SubmitAndWait",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandService",
                        "SubmitAndWait",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits a single composite command, waits for its result, and returns the transaction.
        /// Propagates the gRPC error of failed submissions including Daml interpretation errors.
        pub async fn submit_and_wait_for_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitAndWaitForTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitAndWaitForTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandService/SubmitAndWaitForTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandService",
                        "SubmitAndWaitForTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Submits a single composite command, waits for its result, and returns the transaction tree.
        /// Propagates the gRPC error of failed submissions including Daml interpretation errors.
        pub async fn submit_and_wait_for_transaction_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitAndWaitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitAndWaitForTransactionTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandService/SubmitAndWaitForTransactionTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandService",
                        "SubmitAndWaitForTransactionTree",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits a single composite reassignment command, waits for its result, and returns the reassignment.
        /// Propagates the gRPC error of failed submission.
        pub async fn submit_and_wait_for_reassignment(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitAndWaitForReassignmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitAndWaitForReassignmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandService/SubmitAndWaitForReassignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandService",
                        "SubmitAndWaitForReassignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdatesRequest {
    /// Beginning of the requested ledger section (non-negative integer).
    /// The response will only contain transactions whose offset is strictly greater than this.
    /// If zero, the stream will start from the beginning of the ledger.
    /// If positive, the streaming will start after this absolute offset.
    /// If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
    #[prost(int64, tag = "1")]
    pub begin_exclusive: i64,
    /// End of the requested ledger section.
    /// The response will only contain transactions whose offset is less than or equal to this.
    /// Optional, if empty, the stream will not terminate.
    /// If specified, the stream will terminate after this absolute offset (positive integer) is reached.
    #[prost(int64, optional, tag = "2")]
    pub end_inclusive: ::core::option::Option<i64>,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// Requesting parties with template filters.
    /// Template filters must be empty for GetUpdateTrees requests.
    /// Optional for backwards compatibility, if defined update_format must be unset
    #[prost(message, optional, tag = "3")]
    pub filter: ::core::option::Option<TransactionFilter>,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
    /// In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids
    /// for record fields.
    /// Optional for backwards compatibility, if defined update_format must be unset
    #[prost(bool, tag = "4")]
    pub verbose: bool,
    /// Must be unset for GetUpdateTrees request.
    /// Optional for backwards compatibility for GetUpdates request: defaults to an UpdateFormat where:
    ///
    /// - include_transactions.event_format.filters_by_party = the filter.filters_by_party on this request
    /// - include_transactions.event_format.filters_for_any_party = the filter.filters_for_any_party on this request
    /// - include_transactions.event_format.verbose = the same flag specified on this request
    /// - include_transactions.transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
    /// - include_reassignments.filter = the same filter specified on this request
    /// - include_reassignments.verbose = the same flag specified on this request
    /// - include_topology_events.include_participant_authorization_events.parties = all the parties specified in filter
    #[prost(message, optional, tag = "5")]
    pub update_format: ::core::option::Option<UpdateFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdatesResponse {
    /// The update that matches the filter in the request.
    #[prost(oneof = "get_updates_response::Update", tags = "1, 2, 3, 4")]
    pub update: ::core::option::Option<get_updates_response::Update>,
}
/// Nested message and enum types in `GetUpdatesResponse`.
pub mod get_updates_response {
    /// The update that matches the filter in the request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag = "1")]
        Transaction(super::Transaction),
        #[prost(message, tag = "2")]
        Reassignment(super::Reassignment),
        #[prost(message, tag = "3")]
        OffsetCheckpoint(super::OffsetCheckpoint),
        #[prost(message, tag = "4")]
        TopologyTransaction(super::TopologyTransaction),
    }
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdateTreesResponse {
    /// The update that matches the filter in the request.
    #[prost(oneof = "get_update_trees_response::Update", tags = "1, 2, 3")]
    pub update: ::core::option::Option<get_update_trees_response::Update>,
}
/// Nested message and enum types in `GetUpdateTreesResponse`.
pub mod get_update_trees_response {
    /// The update that matches the filter in the request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag = "1")]
        TransactionTree(super::TransactionTree),
        #[prost(message, tag = "2")]
        Reassignment(super::Reassignment),
        #[prost(message, tag = "3")]
        OffsetCheckpoint(super::OffsetCheckpoint),
    }
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionByOffsetRequest {
    /// The offset of the transaction being looked up.
    /// Must be a valid absolute offset (positive integer).
    /// Required
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// The parties whose events the client expects to see.
    /// Events that are not visible for the parties in this collection will not be present in the response.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Must be set for GetTransactionTreeByOffset request.
    /// Optional for backwards compatibility for GetTransactionByOffset request: if defined transaction_format must be
    /// unset (falling back to defaults).
    #[prost(string, repeated, tag = "2")]
    pub requesting_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Must be unset for GetTransactionTreeByOffset request.
    /// Optional for GetTransactionByOffset request for backwards compatibility: defaults to a TransactionFormat, where:
    ///
    /// - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
    /// - event_format.filters_for_any_party is unset
    /// - event_format.verbose = true
    /// - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
    #[prost(message, optional, tag = "3")]
    pub transaction_format: ::core::option::Option<TransactionFormat>,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionByIdRequest {
    /// The ID of a particular transaction.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
    /// The parties whose events the client expects to see.
    /// Events that are not visible for the parties in this collection will not be present in the response.
    /// Each element must be a valid PartyIdString (as described in ``value.proto``).
    /// Must be set for GetTransactionTreeById request.
    /// Optional for backwards compatibility for GetTransactionById request: if defined transaction_format must be
    /// unset (falling back to defaults).
    #[prost(string, repeated, tag = "2")]
    pub requesting_parties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Must be unset for GetTransactionTreeById request.
    /// Optional for GetTransactionById request for backwards compatibility: defaults to a transaction_format, where:
    ///
    /// - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
    /// - event_format.filters_for_any_party is unset
    /// - event_format.verbose = true
    /// - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
    #[prost(message, optional, tag = "3")]
    pub transaction_format: ::core::option::Option<TransactionFormat>,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionTreeResponse {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionTree>,
}
/// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResponse {
    /// Required
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdateByOffsetRequest {
    /// The offset of the update being looked up.
    /// Must be a valid absolute offset (positive integer).
    /// Required
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// The format for the update.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_format: ::core::option::Option<UpdateFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdateByIdRequest {
    /// The ID of a particular update.
    /// Must be a valid LedgerString (as described in ``value.proto``).
    /// Required
    #[prost(string, tag = "1")]
    pub update_id: ::prost::alloc::string::String,
    /// The format for the update.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_format: ::core::option::Option<UpdateFormat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUpdateResponse {
    /// The update that matches the filter in the request.
    #[prost(oneof = "get_update_response::Update", tags = "1, 2, 3")]
    pub update: ::core::option::Option<get_update_response::Update>,
}
/// Nested message and enum types in `GetUpdateResponse`.
pub mod get_update_response {
    /// The update that matches the filter in the request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag = "1")]
        Transaction(super::Transaction),
        #[prost(message, tag = "2")]
        Reassignment(super::Reassignment),
        #[prost(message, tag = "3")]
        TopologyTransaction(super::TopologyTransaction),
    }
}
/// Generated client implementations.
pub mod update_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to read updates (transactions, (un)assignments, topology events) from the ledger.
    ///
    /// ``GetUpdates`` and ``GetUpdateTrees`` provide a comprehensive stream of updates/changes
    /// which happened on the virtual shared ledger. These streams are indexed with ledger
    /// offsets, which are strictly increasing.
    /// The virtual shared ledger consist of changes happening on multiple synchronizers which are
    /// connected to the serving participant. Each update belongs to one synchronizer, this is
    /// provided in the result (the ``synchronizer_id`` field in ``Transaction`` and ``TransactionTree``
    /// for transactions, the ``source`` field in ``UnassignedEvent`` and the ``target`` field in ``AssignedEvent``).
    /// Consumers can rely on strong causal guarantees on the virtual shared ledger for a single
    /// synchronizer: updates which have greater offsets are happened after than updates with smaller
    /// offsets for the same synchronizer. Across different synchronizers this is not guaranteed.
    #[derive(Debug, Clone)]
    pub struct UpdateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UpdateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UpdateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UpdateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UpdateServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Read the ledger's filtered update stream for the specified contents and filters.
        /// It returns the event types in accordance with the stream contents selected. Also the selection criteria
        /// for individual events depends on the transaction shape chosen.
        ///
        /// - ACS delta: a requesting party must be a stakeholder of an event for it to be included.
        /// - ledger effects: a requesting party must be a witness of an en event for it to be included.
        pub async fn get_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUpdatesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetUpdatesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("com.daml.ledger.api.v2.UpdateService", "GetUpdates"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Read the ledger's complete transaction tree stream and related (un)assignments for a set of parties.
        /// The stream will be filtered only by the parties as wildcard parties.
        /// The template/interface filters describe the respective fields in the ``CreatedEvent`` results.
        pub async fn get_update_trees(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUpdatesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetUpdateTreesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetUpdateTrees",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetUpdateTrees",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Lookup a transaction tree by its offset.
        /// For looking up a transaction instead of a transaction tree, please see GetTransactionByEventId
        /// If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
        pub async fn get_transaction_tree_by_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionByOffsetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetTransactionTreeByOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetTransactionTreeByOffset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Lookup a transaction tree by its ID.
        /// For looking up a transaction instead of a transaction tree, please see GetTransactionById
        /// If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
        pub async fn get_transaction_tree_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetTransactionTreeById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetTransactionTreeById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Lookup a transaction by its offset.
        /// If there is no transaction with this offset, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
        /// Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
        pub async fn get_transaction_by_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionByOffsetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetTransactionByOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetTransactionByOffset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
        /// Lookup a transaction by its ID.
        /// If there is no transaction with this id, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
        /// Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
        pub async fn get_transaction_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetTransactionById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetTransactionById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup an update by its offset.
        /// If there is no update with this offset, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
        pub async fn get_update_by_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUpdateByOffsetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUpdateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetUpdateByOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetUpdateByOffset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup an update by its ID.
        /// If there is no update with this ID, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
        pub async fn get_update_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUpdateByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUpdateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.UpdateService/GetUpdateById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.UpdateService",
                        "GetUpdateById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The submitted commands will be processed atomically in a single transaction. Moreover, each ``Command`` in ``commands`` will be executed in the order specified by the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitRequest {
    /// The commands to be submitted in a single transaction.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub commands: ::core::option::Option<Commands>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitReassignmentRequest {
    /// The reassignment command to be submitted.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub reassignment_commands: ::core::option::Option<ReassignmentCommands>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitReassignmentResponse {}
/// Generated client implementations.
pub mod command_submission_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Allows clients to attempt advancing the ledger's state by submitting commands.
    /// The final states of their submissions are disclosed by the Command Completion Service.
    /// The on-ledger effects of their submissions are disclosed by the Update Service.
    ///
    /// Commands may fail in 2 distinct manners:
    ///
    /// 1. Failure communicated synchronously in the gRPC error of the submission.
    /// 2. Failure communicated asynchronously in a Completion, see ``completion.proto``.
    ///
    /// Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY
    /// choose to produce a completion event for a rejection of a duplicate command.
    ///
    /// Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful.
    /// Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.
    #[derive(Debug, Clone)]
    pub struct CommandSubmissionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CommandSubmissionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CommandSubmissionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CommandSubmissionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CommandSubmissionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submit a single composite command.
        pub async fn submit(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandSubmissionService/Submit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandSubmissionService",
                        "Submit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submit a single reassignment.
        pub async fn submit_reassignment(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitReassignmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitReassignmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.CommandSubmissionService/SubmitReassignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.CommandSubmissionService",
                        "SubmitReassignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
